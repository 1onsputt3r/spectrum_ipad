<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>å…‰è­œåˆ†æ</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    :root{
      --primary-color:#3b82f6;
      --primary-dark:#2563eb;
      --secondary-color:#22c55e;
      --secondary-dark:#16a34a;
      --danger-color:#ef4444;
      --danger-dark:#dc2626;
      --background-color:#f8fafc;
      --text-color:#0f172a;
      --border-color:#cbd5e1;
      --border-radius:10px;
      --safe-area-inset-top:env(safe-area-inset-top,0);
      --safe-area-inset-bottom:env(safe-area-inset-bottom,20px)
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    body{
      font-family:-apple-system,BlinkMacSystemFont,sans-serif;
      margin:0;
      padding:0 12px;
      padding-top:calc(var(--safe-area-inset-top) + 12px);
      padding-bottom:calc(var(--safe-area-inset-bottom) + 12px);
      background-color:var(--background-color);color:var(--text-color);
      overscroll-behavior-y:none;touch-action:manipulation
    }
    .container{max-width:100%;margin:0 auto;padding-bottom:30px}
    .header{
      text-align:center;
      padding:15px 0;
      margin-bottom:20px;
      position:sticky;top:0;
      background-color:var(--background-color);
      z-index:10
    }
    h1{font-size:24px;margin:0;font-weight:600}
    .canvas-container{
      position:relative;width:100%;
      max-width:800px;
      margin:0 auto 20px;
      box-shadow:0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -1px rgba(0,0,0,.06);
      border-radius:var(--border-radius);overflow:visible;
      height:auto;min-height:300px
    }
    canvas{
      display:block;
      width:100%;
      height:auto;
      border-radius:var(--border-radius);touch-action:none
    }
    .file-input-wrapper{
      display:flex;width:100%;
      flex-direction:column;
      gap:10px
    }
    .section{
      background-color:#fff;
      padding:20px;
      margin-bottom:20px;
      border-radius:var(--border-radius);
      box-shadow:0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -1px rgba(0,0,0,.06)
    }
    .section-title{
      font-size:18px;
      font-weight:600;
      margin-top:0;
      margin-bottom:15px;
      padding-bottom:10px;
      border-bottom:1px solid var(--border-color)
    }
    .slider-container{margin-bottom:15px}
    .slider-label{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:8px;
      font-weight:500
    }
    .slider-value{
      font-family:monospace;
      background-color:var(--background-color);
      padding:5px 8px;
      border-radius:5px;
      font-weight:400
    }
    input[type=range]{
      -webkit-appearance:none;
      appearance:none;
      width:100%;
      height:10px;
      border-radius:5px;
      background-color:#e2e8f0;
      outline:0;
      transition:background .2s
    }
    input[type=range]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:26px;
      height:26px;
      border-radius:50%;
      background:var(--primary-color);
      cursor:pointer;
      border:2px solid #fff;
      box-shadow:0 2px 4px rgba(0,0,0,.2);
      transition:background .2s
    }
    input[type=range]::-webkit-slider-thumb:active{
      background:var(--primary-dark);
      transform:scale(1.1)
    }
    .button-row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:15px;
      margin-bottom:5px
    }
    button{
      -webkit-appearance:none;
      appearance:none;
      background-color:var(--primary-color);
      color:#fff;
      border:none;
      padding:12px 20px;
      font-size:16px;
      font-weight:500;
      border-radius:var(--border-radius);
      cursor:pointer;
      flex:1 0 auto;
      min-width:120px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      transition:all .2s;
      box-shadow:0 1px 3px rgba(0,0,0,.1)
    }
    button:active{background-color:var(--primary-dark);transform:translateY(1px)}
    button:disabled{opacity:.6;cursor:not-allowed}
    .btn-secondary{background-color:var(--secondary-color)}
    .btn-secondary:active{background-color:var(--secondary-dark)}
    .btn-danger{background-color:var(--danger-color)}
    .btn-danger:active{background-color:var(--danger-dark)}
    .btn-outline{background-color:transparent;color:var(--primary-color);border:2px solid var(--primary-color)}
    .btn-outline:active{background-color:rgba(59,130,246,.1)}
    .btn-icon{width:44px;min-width:auto;padding:10px}
    .plot-container{width:100%;height:300px;margin-top:20px;margin-bottom:10px}
    .calibration-form{display:flex;gap:10px;margin-bottom:15px;flex-wrap:wrap}
    .calibration-input{flex:1;min-width:180px;display:flex;align-items:center}
    input[type=number]{
      display:block;width:100%;
      padding:12px;
      border:1px solid var(--border-color);
      border-radius:var(--border-radius);
      font-size:16px;background-color:#fff
    }
    input[type=number]:focus{outline:0;border-color:var(--primary-color);box-shadow:0 0 0 2px rgba(59,130,246,.3)}
    input[type=file]{display:none}
    .file-label{
      display:inline-flex;
      padding:12px 20px;
      background-color:var(--secondary-color);color:#fff;
      border-radius:var(--border-radius);
      cursor:pointer;font-weight:500;
      text-align:center;flex:1;
      box-shadow:0 1px 3px rgba(0,0,0,.1);align-items:center;
      justify-content:center;gap:8px
    }
    .file-label:active{background-color:var(--secondary-dark);transform:translateY(1px)}
    .file-name{margin-top:8px;font-size:14px;color:#64748b;word-break:break-all}
    label{display:block;margin-bottom:5px;font-weight:500}
    table{width:100%;border-collapse:collapse;margin-bottom:15px}
    table td,table th{padding:12px 10px;text-align:center;border:1px solid var(--border-color)}
    table th{background-color:#f1f5f9;font-weight:600}
    table tr:nth-child(even){background-color:#f8fafc}
    .cal-result{padding:10px;background-color:#f1f5f9;border-radius:var(--border-radius);font-weight:500;text-align:center;margin-bottom:15px}
    .empty-state{text-align:center;padding:30px 20px;color:#64748b}
    .empty-state svg{width:60px;height:60px;margin-bottom:15px;color:#94a3b8}
    .empty-state h3{margin:0 0 10px;font-weight:600;color:var(--text-color)}
    .empty-state p{margin:0}
    
    /*@media only screen and (min-width:768px){.container{padding:20px;max-width:1000px}
    .plot-container{height:400px}
    button{padding:12px 24px}}
    @media only screen and (min-width:1024px){.container{padding:30px}
    .canvas-container{max-height:none}}
    @media (prefers-color-scheme:dark){:root{--background-color:#0f172a;--text-color:#f8fafc;--border-color:#334155}
    .section{background-color:#1e293b}
    input[type=range]{background-color:#334155}
    input[type=number]{background-color:#1e293b;color:var(--text-color)}
    table th{background-color:#334155}
    table tr:nth-child(even){background-color:#1e293b}
    .cal-result{background-color:#334155}
    .slider-value{background-color:#1e293b}
    .file-name{color:#94a3b8}} */

  .file-input-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center; /* æ°´å¹³ç½®ä¸­ */
    width: 100%;
    gap: 10px;
  }
  .file-input-wrapper > div {
    display: flex;
    justify-content: center; /* æ°´å¹³ç½®ä¸­ */
    width: 100%;
  }
  .file-input-wrapper .file-label {
    display: inline-flex;
    max-width: 250px; /* å¯é¸ï¼šé™åˆ¶æœ€å¤§å¯¬åº¦ */
    justify-content: center; /* æŒ‰éˆ•å…§å®¹ç½®ä¸­ */
  }
  .pixel-adjust-buttons {
    display: inline-flex;
    margin-left: 10px;
  }

  .pixel-btn {
    width: 30px;
    height: 30px;
    min-width: auto;
    padding: 0;
    margin: 0 2px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: bold;
    border-radius: 50%;
  }
  </style>
  <!-- PWA åŸºæœ¬å…ƒæ¨™ç±¤ -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  
  <!-- å¼•ç”¨ manifest.json -->
  <link rel="manifest" href="./manifest.json">

  <!-- å¼•ç”¨ Service Worker è¨»å†Šè…³æœ¬ -->
  <script src="./sw-register.js"></script>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>ğŸ“± å…‰è­œåˆ†æ</h1>
    </div>
    
    <div class="section">
      <h2 class="section-title">åœ–åƒè¼¸å…¥</h2>
      
      <div id="imageEmptyState" class="empty-state">
        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M4 16L8.586 11.414C8.96106 11.0391 9.46967 10.8284 10 10.8284C10.5303 10.8284 11.0389 11.0391 11.414 11.414L16 16M14 14L15.586 12.414C15.9611 12.0391 16.4697 11.8284 17 11.8284C17.5303 11.8284 18.0389 12.0391 18.414 12.414L20 14M14 8H14.01M6 20H18C19.1046 20 20 19.1046 20 18V6C20 4.89543 19.1046 4 18 4H6C4.89543 4 4 4.89543 4 6V18C4 19.1046 4.89543 20 6 20Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <h3>å°šæœªæ·»åŠ åœ–åƒ</h3>
        <p>è«‹ä¸Šå‚³å…‰è­œåœ–åƒä»¥é€²è¡Œåˆ†æ</p>
      </div>
      
      <div class="file-input-wrapper">
        <div style="margin-bottom:15px;">
          <label for="imgInput" class="file-label">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M4 16L8.586 11.414C8.96106 11.0391 9.46967 10.8284 10 10.8284C10.5303 10.8284 11.0389 11.0391 11.414 11.414L16 16M14 14L15.586 12.414C15.9611 12.0391 16.4697 11.8284 17 11.8284C17.5303 11.8284 18.0389 12.0391 18.414 12.414L20 14M14 8H14.01M6 20H18C19.1046 20 20 19.1046 20 18V6C20 4.89543 19.1046 4 18 4H6C4.89543 4 4 4.89543 4 6V18C4 19.1046 4.89543 20 6 20Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            é¸æ“‡å…‰è­œåœ–åƒ
          </label>
          <input type="file" id="imgInput" accept="image/*" />
        </div>
        <div id="imageFileName" class="file-name"></div>
      </div>
      
      <div class="canvas-container" style="display:none;">
        <canvas id="preview" touch-action="none"></canvas>
      </div>
    </div>
    
    <div class="section">
      <h2 class="section-title">é¸æ“‡å€åŸŸ</h2>
      
      <div class="slider-container">
        <div class="slider-label">X èµ·é» <span class="slider-value" id="xStartVal">00000</span></div>
        <input type="range" id="xStart" min="0" max="100" value="0" />
      </div>
      
      <div class="slider-container">
        <div class="slider-label">X çµ‚é» <span class="slider-value" id="xEndVal">00100</span></div>
        <input type="range" id="xEnd" min="0" max="100" value="100" />
      </div>
      
      <div class="button-row">
        <button id="analyzeBtn" class="btn-primary" disabled>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M9 17L15 11L9 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          åˆ†æå…‰è­œ
        </button>
      </div>
      
      <div id="plotEmptyState" class="empty-state">
        <svg viewBox="0 0 24 24" fill="none">
          <path d="M21 21H3V3M20 7L14 13L10 9L4 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <h3>å°šæœªç”¢ç”Ÿåœ–è¡¨</h3>
        <p>è¼‰å…¥åœ–åƒå¾Œï¼Œè¨­å®šç¯„åœä¸¦é»æ“Šåˆ†ææŒ‰éˆ•</p>
      </div>
      
      <div id="plotContainer" style="display:none;">
        <div id="plot" class="plot-container"></div>
      </div>
    </div>
    
    <div class="section">
      <h2 class="section-title">æ³¢é•·æ ¡æ­£</h2>
      
      <div class="slider-container">
        <div class="slider-label">
          ğŸ¯ æ ¡æ­£ç•«ç´  <span class="slider-value" id="xCalibrateVal">00050</span>
          <div class="pixel-adjust-buttons">
            <button id="decreasePixelBtn" class="pixel-btn">-</button>
            <button id="increasePixelBtn" class="pixel-btn">+</button>
          </div>
        </div>
        <input type="range" id="xCalibrate" min="0" max="100" value="50" />
      </div>
      
      <div class="calibration-form">
        <div class="calibration-input">
          <label for="wavelengthInput">å°æ‡‰æ³¢é•· (nm)</label>
          <input type="number" id="wavelengthInput" inputmode="decimal" />
        </div>
        
        <button id="addPointBtn" class="btn-primary" disabled>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M12 4V20M4 12H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          åŠ å…¥æ ¡æ­£é»
        </button>
      </div>
      
      <div style="margin-top:20px;">
        <table id="calibrationTable">
          <thead>
            <tr>
              <th>#</th>
              <th>ç•«ç´ ä½ç½®</th>
              <th>æ³¢é•· (nm)</th>
              <th>æ“ä½œ</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      
      <div class="button-row">
        <button id="generateRegressionBtn" class="btn-secondary" disabled>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M7 15L12 10L17 15M3 10L12 3L21 10M3 21H21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          ç”¢ç”Ÿæ ¡æ­£å›æ­¸ç·š
        </button>
      </div>
      
      <div class="cal-result" id="regressionResult">å°šæœªæ ¡æ­£</div>
    </div>
    
    <div class="section">
      <h2 class="section-title">æ³¢é•·å¼·åº¦åœ–</h2>
      
      <div id="wavelengthPlotEmptyState" class="empty-state">
        <svg viewBox="0 0 24 24" fill="none">
          <path d="M21 21H3V3M20 7L14 13L10 9L4 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <h3>å°šæœªç”¢ç”Ÿæ³¢é•·å¼·åº¦åœ–</h3>
        <p>å®Œæˆæ ¡æ­£å¾Œï¼Œé»æ“Šé¡¯ç¤ºå¼·åº¦-æ³¢é•·åœ–æŒ‰éˆ•</p>
      </div>
      
      <div id="wavelengthPlotContainer" style="display:none;">
        <div id="wavelengthPlot" class="plot-container"></div>
      </div>
      
      <div class="button-row">
        <button id="plotWavelengthBtn" class="btn-primary" disabled>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M21 21H3V3M20 7L14 13L10 9L4 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          é¡¯ç¤ºå¼·åº¦ï¼æ³¢é•·åœ–
        </button>
        <button id="toggleBackgroundBtn" class="btn-outline" disabled>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M4 16L8.586 11.414C8.96106 11.0391 9.46967 10.8284 10 10.8284C10.5303 10.8284 11.0389 11.0391 11.414 11.414L16 16M14 14L15.586 12.414C15.9611 12.0391 16.4697 11.8284 17 11.8284C17.5303 11.8284 18.0389 12.0391 18.414 12.414L20 14M14 8H14.01M6 20H18C19.1046 20 20 19.1046 20 18V6C20 4.89543 19.1046 4 18 4H6C4.89543 4 4 4.89543 4 6V18C4 19.1046 4.89543 20 6 20Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          åŠ å…¥èƒŒæ™¯åœ–
        </button>
      </div>
      
      <div class="button-row" style="margin-top:15px;">
        <button id="exportParamsBtn" class="btn-secondary" disabled>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M3 15C3 17.8284 3 19.2426 3.87868 20.1213C4.75736 21 6.17157 21 9 21H15C17.8284 21 19.2426 21 20.1213 20.1213C21 19.2426 21 17.8284 21 15M12 3L12 15M12 15L16 11M12 15L8 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          åŒ¯å‡ºåˆ†æåƒæ•¸
        </button>
      </div>
      
      <div id="exportedParams" style="margin-top:15px;padding:10px;background-color:#f1f5f9;border-radius:8px;font-family:monospace;display:none;word-break:break-all;"></div>
    </div>
  </div>

  <script>
    // DOMå…ƒç´ èˆ‡å…¨å±€è®Šé‡
    const el = id => document.getElementById(id),
          canvas = el("preview"),
          ctx = canvas.getContext("2d", {alpha: false}),
          img = new Image();
    
    const elems = {
      imgInput: el("imgInput"),
      fileName: el("imageFileName"),
      emptyState: el("imageEmptyState"),
      canvasContainer: document.querySelector(".canvas-container"),
      xStart: el("xStart"),
      xEnd: el("xEnd"),
      xCalibrate: el("xCalibrate"),
      xStartVal: el("xStartVal"),
      xEndVal: el("xEndVal"),
      xCalibrateVal: el("xCalibrateVal"),
      wavelengthInput: el("wavelengthInput"),
      analyzeBtn: el("analyzeBtn"),
      addPointBtn: el("addPointBtn"),
      genRegressionBtn: el("generateRegressionBtn"),
      plotWaveBtn: el("plotWavelengthBtn"),
      toggleBgBtn: el("toggleBackgroundBtn"),
      exportBtn: el("exportParamsBtn"),
      regressResult: el("regressionResult"),
      plotEmpty: el("plotEmptyState"),
      plotCtr: el("plotContainer"),
      waveplotEmpty: el("wavelengthPlotEmptyState"),
      waveplotCtr: el("wavelengthPlotContainer"),
      exportedParams: el("exportedParams")
    };
    
    let calibPoints = [],
        calibration = null,
        regressConfirmed = false,
        imageData, rawData, width, height,
        bgImageOn = false,
        gestureDetected = false,
        lastTouchDist = 0,
        touchStartX = 0,
        canvasDims = {offsetX: 0, offsetY: 0, drawWidth: 0, drawHeight: 0};
    
    // è¨­ç½®ç•«å¸ƒ
    function setupCanvas() {
      const dpr = window.devicePixelRatio || 1,
            container = canvas.parentElement,
            containerWidth = container.clientWidth;
      
      // è¨ˆç®—ç•«å¸ƒå°ºå¯¸
      let canvasW = containerWidth, 
          canvasH = containerWidth * 0.75;
      
      // å¦‚æœæœ‰ç…§ç‰‡ï¼Œæ ¹æ“šç…§ç‰‡æ¯”ä¾‹èª¿æ•´
      if (img.complete && img.naturalWidth > 0) {
        const imgRatio = img.naturalWidth / img.naturalHeight;
        canvasH = containerWidth / imgRatio;
        
        // è¨­å®šé«˜åº¦é™åˆ¶
        canvasH = Math.min(Math.max(canvasH, containerWidth * 0.5), containerWidth * 1.2);
      }
      
      // è¨­ç½®ç•«å¸ƒå°ºå¯¸
      canvas.width = canvasW * dpr;
      canvas.height = canvasH * dpr;
      canvas.style.width = `${canvasW}px`;
      canvas.style.height = `${canvasH}px`;
      
      // èª¿æ•´ç¹ªåœ–ä¸Šä¸‹æ–‡
      ctx.scale(dpr, dpr);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      
      // èª¿æ•´å®¹å™¨
      container.style.height = `${canvasH}px`;
      container.style.overflow = 'visible';
      container.style.maxHeight = 'none';
    }
    
    // ç¹ªè£½åœ–åƒ
    function drawImage() {
      if (!img.complete || !img.naturalWidth) return;
      
      const dpr = window.devicePixelRatio || 1,
            canvasW = canvas.width / dpr,
            canvasH = canvas.height / dpr,
            imgRatio = img.naturalWidth / img.naturalHeight,
            canvasRatio = canvasW / canvasH;
      
      let drawW, drawH, offsetX = 0, offsetY = 0;
      
      if (imgRatio > canvasRatio) {
        drawW = canvasW;
        drawH = canvasW / imgRatio;
        offsetY = (canvasH - drawH) / 2;
      } else {
        drawH = canvasH;
        drawW = canvasH * imgRatio;
        offsetX = (canvasW - drawW) / 2;
      }
      
      ctx.clearRect(0, 0, canvasW, canvasH);
      ctx.drawImage(img, offsetX, offsetY, drawW, drawH);
      
      canvasDims = {offsetX, offsetY, drawWidth: drawW, drawHeight: drawH};
      return canvasDims;
    }
    
    // æ›´æ–°æ»‘æ¡¿
    function updateSliders(max) {
      [elems.xStart, elems.xEnd, elems.xCalibrate].forEach(s => s.max = max);
      elems.xStart.value = 0;
      elems.xEnd.value = max;
      elems.xCalibrate.value = Math.floor(max / 2);
      syncSliderValues();
    }
    
    // åŒæ­¥æ»‘æ¡¿å€¼
    function syncSliderValues() {
      let x1 = parseInt(elems.xStart.value),
          x2 = parseInt(elems.xEnd.value);
      
      if (x2 < x1) [x1, x2] = [x2, x1];
      
      elems.xStartVal.textContent = x1.toString().padStart(5, "0");
      elems.xEndVal.textContent = x2.toString().padStart(5, "0");
      elems.xCalibrateVal.textContent = elems.xCalibrate.value.toString().padStart(5, "0");
      
      elems.xCalibrate.min = x1;
      elems.xCalibrate.max = x2;
      
      requestAnimationFrame(drawWithRect);
    }
    
    // ç¹ªè£½æ–¹æ¡†
    function drawWithRect() {
      if (!img.complete || !img.naturalWidth) return;
      
      const dpr = window.devicePixelRatio || 1,
            canvasW = canvas.width / dpr,
            canvasH = canvas.height / dpr;
      
      ctx.clearRect(0, 0, canvasW, canvasH);
      const {offsetX, offsetY, drawWidth, drawHeight} = drawImage();
      
      let x1 = parseInt(elems.xStart.value),
          x2 = parseInt(elems.xEnd.value);
      
      if (x2 < x1) [x1, x2] = [x2, x1];
      
      // è¨ˆç®—æ¯”ä¾‹
      const xScale = drawWidth / width,
            yScale = drawHeight / height,
            rectX1 = Math.floor(offsetX + x1 * xScale) + 0.5,
            rectX2 = Math.floor(offsetX + x2 * xScale) + 0.5,
            rectY1 = Math.floor(offsetY + height * 0.45 * yScale) + 0.5,
            rectY2 = Math.floor(offsetY + height * 0.55 * yScale) + 0.5;
      
      // ç¹ªè£½çŸ©å½¢
      ctx.strokeStyle = "yellow";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(rectX1, rectY1);
      ctx.lineTo(rectX2, rectY1);
      ctx.lineTo(rectX2, rectY2);
      ctx.lineTo(rectX1, rectY2);
      ctx.closePath();
      ctx.stroke();
    }
    
    // æå–å’Œç¹ªè£½å¼·åº¦åœ–
    function extractAndPlot() {
      if (!rawData) {
        notify("è«‹å…ˆä¸Šå‚³åœ–ç‰‡ï¼");
        return;
      }
      
      // ç²å–é¸å®šç¯„åœ
      let x1 = parseInt(elems.xStart.value),
          x2 = parseInt(elems.xEnd.value);
      
      if (x2 < x1) [x1, x2] = [x2, x1];
      
      const y1 = Math.floor(height * 0.45) + 2,
            y2 = Math.floor(height * 0.55) - 2,
            dataX = [], 
            dataY = [];
      
      // è¨ˆç®—å¹³å‡å¼·åº¦
      for (let x = x1; x <= x2; x++) {
        let sum = 0;
        for (let y = y1; y <= y2; y++) {
          const idx = (y * width + x) * 4;
          if (idx < rawData.length) {
            sum += (rawData[idx] + rawData[idx + 1] + rawData[idx + 2]) / 3;
          }
        }
        dataX.push(x);
        dataY.push(sum / (y2 - y1 + 1));
      }
      
      // ç¹ªè£½æ¨™è¨˜ç·š
      const shapes = [{
        type: "line",
        x0: parseInt(elems.xCalibrate.value),
        x1: parseInt(elems.xCalibrate.value),
        y0: 0,
        y1: Math.max(...dataY),
        line: {color: "red", width: 2, dash: "dot"}
      }];
      
      // é¡¯ç¤ºåœ–è¡¨
      elems.plotEmpty.style.display = "none";
      elems.plotCtr.style.display = "block";
      
      // æ›´æ–°æˆ–å‰µå»ºåœ–è¡¨
      const plotEl = document.getElementById('plot');
      if (plotEl.data && plotEl.data.length > 0) {
        Plotly.update('plot', {x: [dataX], y: [dataY]}, {shapes});
      } else {
        Plotly.newPlot("plot", [{
          x: dataX,
          y: dataY,
          mode: "lines",
          name: "åƒç´ å¼·åº¦",
          line: {color: "#3b82f6", width: 3}
        }], {
          margin: {t: 20, r: 20, b: 40, l: 50},
          xaxis: {
            title: "åƒç´ ä½ç½®",
            showline: true,
            mirror: true,
            ticks: 'outside',
            linecolor: 'black',
            linewidth: 2,
            tickfont: {size: 14}
          },
          yaxis: {
            title: "å¼·åº¦",
            showline: true,
            mirror: true,
            ticks: 'outside',
            linecolor: 'black',
            linewidth: 2,
            tickfont: {size: 14}
          },
          shapes: shapes,
          dragmode: 'pan',
          modeBarButtonsToAdd: [
            'hoverClosestCartesian',
            'hoverCompareCartesian',
            'toggleSpikelines'
          ],
          hovermode: 'closest',
          colorway: ['#3b82f6', '#ef4444', '#22c55e'],
          plot_bgcolor: 'rgba(255,255,255)',
          paper_bgcolor: 'rgba(255,255,255)'
        }, {
          displayModeBar: true,
          responsive: true,
          toImageButtonOptions: {
            format: 'png',
            filename: 'spectrum_intensity.png', // æ·»åŠ å‰¯æª”å
            scale: 2
          },
          modeBarButtonsToRemove: [
            'lasso2d',
            'select2d',
            'autoScale2d'
          ]
        });
      }
      
      // å•Ÿç”¨æ ¡æ­£æŒ‰éˆ•
      elems.addPointBtn.disabled = false;

      // åœ¨å‰µå»ºåœ–è¡¨å¾Œè¨­ç½®è‡ªå®šç¾©ä¸‹è¼‰æŒ‰éˆ•
      setTimeout(() => setupCustomDownloadButton('plot', 'spectrum_intensity.png'), 500);
    }
    
    // æ›´æ–°æ ¡æ­£è¡¨æ ¼
    function updateCalibTable() {
      const tbody = document.querySelector("#calibrationTable tbody");
      tbody.innerHTML = "";
      
      calibPoints.forEach((p, i) => {
        const row = document.createElement("tr");
        
        // å»ºç«‹å–®å…ƒæ ¼
        const cells = [
          {text: i + 1},
          {text: p.pixel},
          {text: p.wavelength.toFixed(2)},
          {html: createDeleteBtn(i)}
        ];
        
        cells.forEach(cell => {
          const td = document.createElement("td");
          if (cell.text !== undefined) td.textContent = cell.text;
          if (cell.html) td.appendChild(cell.html);
          row.appendChild(td);
        });
        
        tbody.appendChild(row);
      });
      
      // æ›´æ–°å›æ­¸æŒ‰éˆ•ç‹€æ…‹
      elems.genRegressionBtn.disabled = calibPoints.length < 2;
    }
    
    // å‰µå»ºåˆªé™¤æŒ‰éˆ•
    function createDeleteBtn(index) {
      const btn = document.createElement("button");
      btn.textContent = "âŒ";
      btn.classList.add("btn-icon");
      btn.style.margin = "0 auto";
      btn.style.display = "block";
      btn.style.backgroundColor = "white";
      btn.style.border = "2px solid #ef4444";
      btn.style.color = "#ef4444";
      btn.style.width = "36px";
      btn.style.height = "36px";
      btn.style.padding = "0";
      btn.style.minWidth = "auto";
      
      btn.onclick = e => {
        e.preventDefault();
        calibPoints.splice(index, 1);
        regressConfirmed = false;
        calibration = null;
        elems.regressResult.textContent = "å°šæœªæ ¡æ­£";
        updateCalibTable();
        updateButtonStates();
      };
      
      return btn;
    }
    
    // ç²å–é¸å®šç¯„åœçš„åœ–åƒæ•¸æ“šURL
    function getSelectedImageURL(x1, x2, y1, y2) {
      const cropCanvas = document.createElement("canvas"),
            cropCtx = cropCanvas.getContext("2d"),
            cropWidth = x2 - x1 + 1,
            cropHeight = y2 - y1 + 1;
      
      cropCanvas.width = cropWidth;
      cropCanvas.height = cropHeight;
      
      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = width;
      tempCanvas.height = height;
      const tempCtx = tempCanvas.getContext("2d");
      tempCtx.putImageData(imageData, 0, 0);
      
      try {
        const cropImageData = tempCtx.getImageData(x1, y1, cropWidth, cropHeight);
        cropCtx.putImageData(cropImageData, 0, 0);
        return cropCanvas.toDataURL();
      } catch (e) {
        console.error("è£å‰ªåœ–åƒç™¼ç”ŸéŒ¯èª¤:", e);
        return null;
      }
    }
    
    // ç¹ªè£½æ³¢é•·å¼·åº¦åœ–
    function plotWavelengthGraph() {
      if (!rawData) {
        notify("è«‹å…ˆä¸Šå‚³åœ–ç‰‡ï¼");
        return;
      }
      
      if (!calibration) {
        notify("è«‹å…ˆåŠ å…¥è‡³å°‘å…©å€‹æ ¡æ­£é»ï¼Œä¸¦å®Œæˆæ ¡æ­£ï¼", "error");
        return;
      }
      
      // ç²å–è³‡æ–™
      let x1 = parseInt(elems.xStart.value),
          x2 = parseInt(elems.xEnd.value);
      
      if (x2 < x1) [x1, x2] = [x2, x1];
      
      const y1 = Math.floor(height * 0.45) + 2,
            y2 = Math.floor(height * 0.55) - 2,
            dataX = [],
            dataY = [];
      
      // è¨ˆç®—å¼·åº¦
      for (let x = x1; x <= x2; x++) {
        let sum = 0;
        for (let y = y1; y <= y2; y++) {
          const idx = (y * width + x) * 4;
          if (idx < rawData.length) {
            sum += (rawData[idx] + rawData[idx + 1] + rawData[idx + 2]) / 3;
          }
        }
        dataX.push(x);
        dataY.push(sum / (y2 - y1 + 1));
      }
      
      // è½‰æ›ç‚ºæ³¢é•·
      const {a, b} = calibration;
      const wavelengthX = dataX.map(x => a * x + b);
      
      // é¡¯ç¤ºåœ–è¡¨
      elems.waveplotEmpty.style.display = "none";
      elems.waveplotCtr.style.display = "block";
      
      // å»ºç«‹åœ–è¡¨
      Plotly.newPlot("wavelengthPlot", [{
        x: wavelengthX,
        y: dataY,
        mode: "lines",
        name: "æ³¢é•·å¼·åº¦",
        line: {color: "#22c55e", width: 3}
      }], {
        margin: {t: 20, r: 20, b: 40, l: 50},
        xaxis: {
          title: "æ³¢é•· (nm)",
          showline: true,
          mirror: true,
          ticks: 'outside',
          linecolor: 'black',
          linewidth: 2,
          tickfont: {size: 14}
        },
        yaxis: {
          title: "å¼·åº¦",
          showline: true,
          mirror: true,
          ticks: 'outside',
          linecolor: 'black',
          linewidth: 2,
          tickfont: {size: 14}
        },
        dragmode: 'pan',
        modeBarButtonsToAdd: [
          'hoverClosestCartesian',
          'hoverCompareCartesian',
          'toggleSpikelines'
        ],
        hovermode: 'closest',
        images: [],
        plot_bgcolor: 'rgba(255,255,255)',
        paper_bgcolor: 'rgba(255,255,255)'
      }, {
        displayModeBar: true,
        responsive: true,
        toImageButtonOptions: {
          format: 'png',
          filename: 'spectrum_wavelength.png', // æ·»åŠ å‰¯æª”å
          scale: 2
        },
        modeBarButtonsToRemove: [
          'lasso2d',
          'select2d',
          'autoScale2d'
        ]
      });
      
     // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
    elems.toggleBgBtn.disabled = false;
    bgImageOn = false;
    elems.toggleBgBtn.textContent = "ğŸ–¼ åŠ å…¥èƒŒæ™¯åœ–";
    elems.toggleBgBtn.classList.add("btn-outline");
    elems.toggleBgBtn.classList.remove("btn-danger");
    elems.exportBtn.disabled = false;

    // åœ¨å‰µå»ºåœ–è¡¨å¾Œè¨­ç½®è‡ªå®šç¾©ä¸‹è¼‰æŒ‰éˆ•
    setTimeout(() => setupCustomDownloadButton('wavelengthPlot', 'spectrum_wavelength.png'), 500);
    }
    
    // åˆ‡æ›èƒŒæ™¯åœ–
    function toggleBackground() {
      if (!rawData || !calibration) {
        notify("è«‹å…ˆåŠ å…¥è‡³å°‘å…©å€‹æ ¡æ­£é»ï¼Œä¸¦å®Œæˆæ ¡æ­£ï¼", "error");
        return;
      }
      
      // ç²å–ç¯„åœ
      let x1 = parseInt(elems.xStart.value),
          x2 = parseInt(elems.xEnd.value);
      
      if (x2 < x1) [x1, x2] = [x2, x1];
      
      const y1 = Math.floor(height * 0.45) + 2,
            y2 = Math.floor(height * 0.55) - 2,
            {a, b} = calibration,
            wlStart = a * x1 + b,
            wlEnd = a * x2 + b;
      
      if (!bgImageOn) {
        // åŠ å…¥èƒŒæ™¯åœ–
        const imageDataUrl = getSelectedImageURL(x1, x2, y1, y2);
        
        if (imageDataUrl) {
          Plotly.relayout("wavelengthPlot", {
            images: [{
              source: imageDataUrl,
              xref: "x",
              yref: "paper",
              x: wlStart,
              y: 1,
              sizex: wlEnd - wlStart,
              sizey: 1,
              sizing: "stretch",
              opacity: 0.6,
              layer: "below"
            }]
          });
          
          bgImageOn = true;
          elems.toggleBgBtn.textContent = "ğŸš« ç§»é™¤èƒŒæ™¯åœ–";
          elems.toggleBgBtn.classList.remove("btn-outline");
          elems.toggleBgBtn.classList.add("btn-danger");
        } else {
          notify("ç„¡æ³•ç”ŸæˆèƒŒæ™¯åœ–ç‰‡ï¼Œè«‹æª¢æŸ¥é¸æ“‡ç¯„åœï¼", "error");
        }
      } else {
        // ç§»é™¤èƒŒæ™¯åœ–
        Plotly.relayout("wavelengthPlot", {images: []});
        
        bgImageOn = false;
        elems.toggleBgBtn.textContent = "ğŸ–¼ åŠ å…¥èƒŒæ™¯åœ–";
        elems.toggleBgBtn.classList.add("btn-outline");
        elems.toggleBgBtn.classList.remove("btn-danger");
      }
      // åœ¨å‰µå»ºåœ–è¡¨å¾Œè¨­ç½®è‡ªå®šç¾©ä¸‹è¼‰æŒ‰éˆ•
      setTimeout(() => setupCustomDownloadButton('wavelengthPlot', 'spectrum_wavelength.png'), 500);
    }
    
    // åœ–ç‰‡åŠ è¼‰è™•ç†
    function loadImage(file) {
      if (!file) return;
      
      // é‡ç½®æ•¸æ“š
      resetData();
      
      // é¡¯ç¤ºæ–‡ä»¶å
      elems.fileName.textContent = file.name;
      
      const reader = new FileReader();
      
      reader.onload = e => {
        img.onload = () => {
          // è¨­ç½®åœ–ç‰‡å°ºå¯¸
          width = img.naturalWidth;
          height = img.naturalHeight;
          
          // æ›´æ–°ç•Œé¢
          elems.emptyState.style.display = 'none';
          
          // è¨­ç½®ç•«å¸ƒå®¹å™¨
          elems.canvasContainer.style.display = 'block';
          elems.canvasContainer.style.overflow = 'visible';
          elems.canvasContainer.style.height = 'auto';
          elems.canvasContainer.style.maxHeight = 'none';
          
          // è¨­ç½®ç•«å¸ƒ
          setupCanvas();
          updateSliders(width - 1);
          
          // è™•ç†åœ–ç‰‡
          (img.decode ? img.decode() : Promise.resolve())
            .then(processImage)
            .catch(err => {
              console.error("åœ–ç‰‡è§£ç¢¼å¤±æ•—:", err);
              processImage();
            });
        };
        
        img.src = e.target.result;
      };
      
      reader.readAsDataURL(file);
    }
    
    // é‡ç½®æ•¸æ“š
    function resetData() {
      calibPoints = [];
      calibration = null;
      regressConfirmed = false;
      elems.regressResult.textContent = "å°šæœªæ ¡æ­£";
      updateCalibTable();

      Plotly.purge("plot");
      Plotly.purge("wavelengthPlot");

      elems.plotEmpty.style.display = "block";
      elems.plotCtr.style.display = "none";
      elems.waveplotEmpty.style.display = "block";
      elems.waveplotCtr.style.display = "none";

      bgImageOn = false;
      elems.toggleBgBtn.textContent = "ğŸ–¼ åŠ å…¥èƒŒæ™¯åœ–";
      elems.toggleBgBtn.classList.add("btn-outline");
      elems.toggleBgBtn.classList.remove("btn-danger");

      elems.wavelengthInput.value = "";

      // ğŸ”½ æ–°å¢é€™ä¸€æ®µ
      elems.exportedParams.innerHTML = "";
      elems.exportedParams.style.display = "none";

      elems.xStartVal.textContent = "00000";
      elems.xEndVal.textContent = "00100";
      elems.xCalibrateVal.textContent = "00050";

      elems.xStart.value = 0;
      elems.xEnd.value = width - 1;
      elems.xCalibrate.value = Math.floor((width - 1) / 2);

      const tbody = document.querySelector("#calibrationTable tbody");
      tbody.innerHTML = "";

      elems.exportBtn.disabled = true;

      updateButtonStates();
    }

    
    // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
    function updateButtonStates() {
      const hasImage = img.complete && img.naturalWidth > 0,
            hasAnalyzed = elems.plotCtr.style.display === "block",
            hasCalibration = calibration !== null && regressConfirmed;
      
      elems.analyzeBtn.disabled = !hasImage;
      elems.addPointBtn.disabled = !hasAnalyzed;
      elems.genRegressionBtn.disabled = calibPoints.length < 2;
      elems.plotWaveBtn.disabled = !hasCalibration;
      elems.toggleBgBtn.disabled = !hasCalibration || elems.waveplotCtr.style.display === "none";
      elems.exportBtn.disabled = !hasCalibration;
    }
    
    // è™•ç†åœ–ç‰‡
    function processImage() {
      // å‰µå»ºè‡¨æ™‚ç•«å¸ƒç²å–åƒç´ æ•¸æ“š
      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = width;
      tempCanvas.height = height;
      const tempCtx = tempCanvas.getContext("2d");
      tempCtx.drawImage(img, 0, 0);
      
      try {
        imageData = tempCtx.getImageData(0, 0, width, height);
        rawData = imageData.data;
        
        drawWithRect();
        notify("åœ–ç‰‡å·²æˆåŠŸè¼‰å…¥", "success");
        
        // å•Ÿç”¨åˆ†ææŒ‰éˆ•
        elems.analyzeBtn.disabled = false;
      } catch (e) {
        console.error("è™•ç†åœ–ç‰‡æ™‚ç™¼ç”ŸéŒ¯èª¤:", e);
        notify("åœ–ç‰‡è™•ç†å¤±æ•—ï¼Œè«‹å˜—è©¦ä½¿ç”¨å…¶ä»–åœ–ç‰‡ã€‚", "error");
      }
    }
    
    // æ·»åŠ æ ¡æ­£é»
    function addCalibPoint() {
      const pixel = parseInt(elems.xCalibrate.value),
            wavelength = parseFloat(elems.wavelengthInput.value);
      
      if (isNaN(pixel) || isNaN(wavelength)) {
        notify("è«‹è¼¸å…¥æœ‰æ•ˆçš„ç•«ç´ èˆ‡æ³¢é•·ï¼", "error");
        return;
      }
      
      calibPoints.push({pixel, wavelength});
      regressConfirmed = false;
      calibration = null;
      elems.regressResult.textContent = "å°šæœªæ ¡æ­£";
      updateCalibTable();
      notify("å·²åŠ å…¥æ ¡æ­£é»", "success");
      elems.wavelengthInput.value = "";
      
      updateButtonStates();
    }
    
    // ç”Ÿæˆå›æ­¸ç·š
    function generateRegression() {
      if (calibPoints.length < 2) {
        notify("è«‹è‡³å°‘è¼¸å…¥å…©å€‹æ ¡æ­£é»ï¼", "error");
        return;
      }
      
      // ç·šæ€§å›æ­¸
      let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
      const n = calibPoints.length;
      
      calibPoints.forEach(p => {
        sumX += p.pixel;
        sumY += p.wavelength;
        sumXY += p.pixel * p.wavelength;
        sumX2 += p.pixel * p.pixel;
      });
      
      const a = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      const b = (sumY - a * sumX) / n;
      
      calibration = {a, b};
      regressConfirmed = true;
      
      elems.regressResult.textContent = `Î» = ${a.toFixed(4)} Ã— x + ${b.toFixed(2)}`;
      notify("å·²ç”Ÿæˆæ ¡æ­£æ–¹ç¨‹å¼", "success");
      
      updateButtonStates();
    }
    
    // åŒ¯å‡ºåˆ†æåƒæ•¸
    function exportParams() {
      if (!rawData || !calibration) {
        notify("è«‹å…ˆå®Œæˆæ³¢é•·æ ¡æ­£ï¼", "error");
        return;
      }
      
      // ç²å–åƒæ•¸
      const x1 = parseInt(elems.xStart.value),
            x2 = parseInt(elems.xEnd.value),
            {a, b} = calibration,
            params = {
              xStart: x1,
              xEnd: x2,
              wavelengthStart: a * x1 + b,
              wavelengthEnd: a * x2 + b,
              regressionSlope: a,
              regressionIntercept: b,
              calibrationPoints: calibPoints
            };
      
      // é¡¯ç¤ºåƒæ•¸
      elems.exportedParams.innerHTML = `<div style="font-weight:bold;margin-bottom:5px;">åˆ†æåƒæ•¸ï¼š</div>`;
      elems.exportedParams.innerHTML += `Xèµ·é»: ${params.xStart} (${params.wavelengthStart.toFixed(2)} nm)<br>`;
      elems.exportedParams.innerHTML += `Xçµ‚é»: ${params.xEnd} (${params.wavelengthEnd.toFixed(2)} nm)<br>`;
      elems.exportedParams.innerHTML += `å›æ­¸ç·šæ–œç‡: ${params.regressionSlope.toFixed(6)}<br>`;
      elems.exportedParams.innerHTML += `å›æ­¸ç·šæˆªè·: ${params.regressionIntercept.toFixed(6)}<br>`;
      
      // å‰µå»ºä¸‹è¼‰æŒ‰éˆ•
      const buttonArea = document.createElement("div");
      buttonArea.style.marginTop = "15px";
      buttonArea.style.display = "flex";
      buttonArea.style.justifyContent = "flex-end";
      
      const downloadBtn = document.createElement("button");
      downloadBtn.textContent = "ä¸‹è¼‰CSV";
      downloadBtn.classList.add("btn-secondary");
      downloadBtn.onclick = () => {
        // å»ºç«‹CSVå…§å®¹
        let csv = "åƒæ•¸åç¨±,æ•¸å€¼\n";
        csv += `xStart,${params.xStart}\n`;
        csv += `xEnd,${params.xEnd}\n`;
        csv += `wavelengthStart,${params.wavelengthStart.toFixed(6)}\n`;
        csv += `wavelengthEnd,${params.wavelengthEnd.toFixed(6)}\n`;
        csv += `regressionSlope,${params.regressionSlope.toFixed(6)}\n`;
        csv += `regressionIntercept,${params.regressionIntercept.toFixed(6)}\n\n`;
        
        // æ·»åŠ æ ¡æ­£é»
        csv += "calibration_index,pixel,wavelength\n";
        params.calibrationPoints.forEach((p, i) => {
          csv += `${i+1},${p.pixel},${p.wavelength.toFixed(6)}\n`;
        });
        
        // é‡å° iOS å„ªåŒ–çš„ä¸‹è¼‰æ–¹æ³•
        const filename = "spectrum_parameters.csv";
        const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});

        // æª¢æ¸¬æ˜¯å¦ç‚º iOS è£ç½®
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

        if (isIOS) {
          // iOS è£ç½®å°ˆç”¨ä¸‹è¼‰æ–¹æ³•
          const reader = new FileReader();
          reader.onload = function() {
            const link = document.createElement('a');
            link.href = reader.result;
            link.download = filename;
            link.target = '_blank';
            link.rel = 'noopener';
            
            // è¨­ç½®é¡å¤–çš„å±¬æ€§ä¾†å¹«åŠ©è­˜åˆ¥æª”æ¡ˆé¡å‹
            link.setAttribute('type', 'text/csv');
            link.setAttribute('data-downloadurl', ['text/csv', filename, link.href].join(':'));
            
            document.body.appendChild(link);
            link.click();
            setTimeout(() => document.body.removeChild(link), 100);
          };
          reader.readAsDataURL(blob);
        } else {
          // å…¶ä»–è£ç½®çš„æ¨™æº–ä¸‹è¼‰æ–¹æ³•
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = filename;
          link.style.visibility = 'hidden';
          document.body.appendChild(link);
          link.click();
          setTimeout(() => {
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
          }, 100);
        }
        
        notify("CSVæª”æ¡ˆå·²ä¸‹è¼‰", "success");
      };
      
      buttonArea.appendChild(downloadBtn);
      
      // ç§»é™¤èˆŠæŒ‰éˆ•ï¼Œæ·»åŠ æ–°æŒ‰éˆ•
      const oldBtn = document.getElementById("copyParamsBtn");
      if (oldBtn) oldBtn.remove();
      
      elems.exportedParams.appendChild(buttonArea);
      elems.exportedParams.style.display = "block";
      
      notify("å·²åŒ¯å‡ºåˆ†æåƒæ•¸", "success");
    }
    
    // é¡¯ç¤ºé€šçŸ¥
    function notify(message, type = "info", duration = 2000) {
      const notification = document.createElement("div");
      notification.textContent = message;
      notification.style.cssText = `
        position:fixed;
        bottom:20px;
        left:50%;
        transform:translateX(-50%);
        padding:12px 20px;
        border-radius:8px;
        font-weight:500;
        box-shadow:0 4px 12px rgba(0,0,0,.15);
        z-index:9999;
        max-width:80%;
        text-align:center;
        background-color:${type === "success" ? "#22c55e" : type === "error" ? "#ef4444" : "#3b82f6"};
        color:white;
      `;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.opacity = "0";
        notification.style.transition = "opacity 0.5s ease";
        setTimeout(() => document.body.removeChild(notification), 500);
      }, duration);
    }
    
    // è¨­ç½®å¤šé»è§¸æ§
    function setupGestures() {
      // è§¸æ§é–‹å§‹
      canvas.addEventListener('touchstart', e => {
        if (e.touches.length === 2) {
          // é›™æŒ‡è§¸æ§
          gestureDetected = true;
          const t1 = e.touches[0], t2 = e.touches[1];
          lastTouchDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
          touchStartX = (t1.clientX + t2.clientX) / 2;
        } else if (e.touches.length === 1) {
          // å–®æŒ‡è§¸æ§
          touchStartX = e.touches[0].clientX;
        }
        e.preventDefault();
      }, {passive: false});
      
      // è§¸æ§ç§»å‹•
      canvas.addEventListener('touchmove', e => {
        if (e.touches.length === 2 && gestureDetected) {
          // é›™æŒ‡æ‰‹å‹¢
          const t1 = e.touches[0], t2 = e.touches[1];
          const touchDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
          
          // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹
          const scale = touchDist / lastTouchDist;
          lastTouchDist = touchDist;
          
          // è¨ˆç®—ä¸­å¿ƒé»
          const touchX = (t1.clientX + t2.clientX) / 2;
          const touchDX = touchX - touchStartX;
          touchStartX = touchX;
          
          // æ‡‰ç”¨æ“ä½œ
          if (Math.abs(scale - 1) > 0.05) {
            // ç¸®æ”¾
            const x1 = parseInt(elems.xStart.value);
            const x2 = parseInt(elems.xEnd.value);
            const range = x2 - x1;
            const mid = (x1 + x2) / 2;
            
            const newRange = Math.max(10, Math.min(width - 1, range * scale));
            const newX1 = Math.max(0, Math.round(mid - newRange / 2));
            const newX2 = Math.min(width - 1, Math.round(mid + newRange / 2));
            
            elems.xStart.value = newX1;
            elems.xEnd.value = newX2;
            syncSliderValues();
          } else if (Math.abs(touchDX) > 5) {
            // å¹³ç§»
            const x1 = parseInt(elems.xStart.value);
            const x2 = parseInt(elems.xEnd.value);
            const range = x2 - x1;
            
            // è¨ˆç®—ç§»å‹•åƒç´ 
            const pixelDelta = Math.round(touchDX * width / canvas.clientWidth);
            
            if (Math.abs(pixelDelta) > 0) {
              let newX1 = x1 + pixelDelta;
              let newX2 = x2 + pixelDelta;
              
              // é‚Šç•Œæª¢æŸ¥
              if (newX1 < 0) {
                newX1 = 0;
                newX2 = range;
              }
              
              if (newX2 > width - 1) {
                newX2 = width - 1;
                newX1 = newX2 - range;
              }
              
              elems.xStart.value = newX1;
              elems.xEnd.value = newX2;
              syncSliderValues();
            }
          }
        } else if (e.touches.length === 1 && !gestureDetected) {
          // å–®æŒ‡ç§»å‹•
          const touch = e.touches[0];
          const touchDX = touch.clientX - touchStartX;
          touchStartX = touch.clientX;
          
          // ç§»å‹•æ ¡æ­£é»
          const pixelDelta = Math.round(touchDX * width / canvas.clientWidth);
          
          if (Math.abs(pixelDelta) > 0) {
            const newPos = parseInt(elems.xCalibrate.value) + pixelDelta;
            elems.xCalibrate.value = Math.max(elems.xCalibrate.min, Math.min(elems.xCalibrate.max, newPos));
            syncSliderValues();
            if (rawData) extractAndPlot();
          }
        }
        e.preventDefault();
      }, {passive: false});
      
      // è§¸æ§çµæŸ
      canvas.addEventListener('touchend', e => {
        gestureDetected = false;
        
        // æ›´æ–°åœ–è¡¨
        if (e.touches.length === 0 && rawData) extractAndPlot();
      });
      
      // é˜»æ­¢ç¸®æ”¾
      canvas.addEventListener('gesturestart', e => e.preventDefault(), {passive: false});
    }
    
    // åˆå§‹åŒ–äº‹ä»¶ç›£è½
    function setupEvents() {
      // æª”æ¡ˆé¸æ“‡
      elems.imgInput.addEventListener("change", e => {
        if (e.target.files && e.target.files[0]) {
          loadImage(e.target.files[0]);
          e.target.value = ''; // é‡ç½®è¼¸å…¥
        }
      });
      
      // æ»‘æ¡¿äº‹ä»¶
      elems.xStart.addEventListener("input", syncSliderValues);
      elems.xEnd.addEventListener("input", syncSliderValues);
      elems.xCalibrate.addEventListener("input", () => {
        syncSliderValues();
        if (rawData) extractAndPlot();
      });
      
      // æŒ‰éˆ•äº‹ä»¶
      elems.analyzeBtn.addEventListener("click", extractAndPlot);
      elems.addPointBtn.addEventListener("click", addCalibPoint);
      elems.genRegressionBtn.addEventListener("click", generateRegression);
      elems.plotWaveBtn.addEventListener("click", plotWavelengthGraph);
      elems.toggleBgBtn.addEventListener("click", toggleBackground);
      elems.exportBtn.addEventListener("click", exportParams);
      
      // ç‚ºåƒç´ èª¿æ•´æŒ‰éˆ•æ·»åŠ äº‹ä»¶ç›£è½
      document.getElementById('decreasePixelBtn').addEventListener('click', () => {
        const calibrateEl = elems.xCalibrate;
        const currentValue = parseInt(calibrateEl.value);
        const newValue = Math.max(parseInt(calibrateEl.min), currentValue - 1);
        calibrateEl.value = newValue;
        syncSliderValues();
        if (rawData) extractAndPlot();
      });

      document.getElementById('increasePixelBtn').addEventListener('click', () => {
        const calibrateEl = elems.xCalibrate;
        const currentValue = parseInt(calibrateEl.value);
        const newValue = Math.min(parseInt(calibrateEl.max), currentValue + 1);
        calibrateEl.value = newValue;
        syncSliderValues();
        if (rawData) extractAndPlot();
      });
      // æ³¢é•·è¼¸å…¥å›è»Š
      elems.wavelengthInput.addEventListener("keydown", e => {
        if (e.key === "Enter") {
          e.preventDefault();
          addCalibPoint();
        }
      });
      
      // çª—å£èª¿æ•´å¤§å°
      window.addEventListener('resize', () => {
        if (img.complete && img.naturalWidth > 0) {
          setupCanvas();
          requestAnimationFrame(drawWithRect);
        }
      });
      
      // ç¦ç”¨é é¢ç¸®æ”¾
      document.addEventListener('gesturestart', e => e.preventDefault(), {passive: false});
      document.addEventListener('gesturechange', e => e.preventDefault(), {passive: false});
    }
    
    // åˆå§‹åŒ–æ‡‰ç”¨
    function init() {
      // è¨­ç½®ç•«å¸ƒå®¹å™¨æ¨£å¼
      if (elems.canvasContainer) {
        elems.canvasContainer.style.overflow = 'visible';
        elems.canvasContainer.style.height = 'auto';
        elems.canvasContainer.style.minHeight = '300px';
        elems.canvasContainer.style.maxHeight = 'none';
      }
      
      setupCanvas();
      setupEvents();
      setupGestures();
      updateButtonStates();
      
      // é¡¯ç¤ºç‰ˆæœ¬ä¿¡æ¯
      const versionDiv = document.createElement('div');
      versionDiv.style.cssText = 'text-align:center;margin-top:20px;font-size:12px;color:#666;';
      versionDiv.innerHTML = 'å…‰è­œåˆ†æå·¥å…· v1.8 - æª”æ¡ˆä¸‹è¼‰å„ªåŒ–ç‰ˆ';
      document.querySelector('.container').appendChild(versionDiv);
    }

    function setupCustomDownloadButton(plotId, filename = 'spectrum.png') {
      const modebar = document.querySelector(`#${plotId} .modebar`);
      if (!modebar) return;

      const downloadBtn = modebar.querySelector(".modebar-btn[data-title='Download plot as a png']");
      if (!downloadBtn) return;

      // å…ˆç§»é™¤åŸæœ¬ onclick
      downloadBtn.onclick = null;

      // æ”¹æˆæ‰‹å‹•è™•ç†ä¸‹è¼‰
      downloadBtn.addEventListener("click", async (e) => {
        e.preventDefault();
        try {
          // å…ˆæš«æ™‚è¨­å®šç™½è‰²èƒŒæ™¯ç”¨æ–¼ä¸‹è¼‰
          Plotly.relayout(plotId, {
            plot_bgcolor: 'rgb(255,255,255)',
            paper_bgcolor: 'rgb(255,255,255)'
          });
          
          const dataUrl = await Plotly.toImage(plotId, {
            format: "png",
            height: 600,
            width: 800,
            scale: 2
          });

          const link = document.createElement("a");
          link.href = dataUrl;
          link.download = filename; // ğŸ”¥ æŒ‡å®šæ˜ç¢ºçš„å‰¯æª”å
          link.target = "_blank";
          link.rel = "noopener";

          // iOS ç‰¹åˆ¥è™•ç†ï¼šä½¿ç”¨ data URL é–‹å•Ÿæ–°é ç±¤æ¯”è¼ƒç©©
          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
          if (isIOS) {
            const win = window.open();
            win.document.write(`<html><body style="margin:0;"><img src="${dataUrl}" style="width:100%;"/></body></html>`);
          } else {
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          }

        } catch (err) {
          console.error("ä¸‹è¼‰åœ–åƒå¤±æ•—ï¼š", err);
          notify("åœ–åƒä¸‹è¼‰å¤±æ•—", "error");
        }
      });
    }

    // å•Ÿå‹•æ‡‰ç”¨
    init();


  </script>
</body>
</html>
