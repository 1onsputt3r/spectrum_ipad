<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>光譜分析</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    :root{
      --primary-color:#3b82f6;
      --primary-dark:#2563eb;
      --secondary-color:#22c55e;
      --secondary-dark:#16a34a;
      --danger-color:#ef4444;
      --danger-dark:#dc2626;
      --background-color:#f8fafc;
      --text-color:#0f172a;
      --border-color:#cbd5e1;
      --border-radius:10px;
      --safe-area-inset-top:env(safe-area-inset-top,0);
      --safe-area-inset-bottom:env(safe-area-inset-bottom,20px)
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    body{
      font-family:-apple-system,BlinkMacSystemFont,sans-serif;
      margin:0;
      padding:0 12px;
      padding-top:calc(var(--safe-area-inset-top) + 12px);
      padding-bottom:calc(var(--safe-area-inset-bottom) + 12px);
      background-color:var(--background-color);color:var(--text-color);
      overscroll-behavior-y:none;touch-action:manipulation
    }
    .container{max-width:100%;margin:0 auto;padding-bottom:30px}
    .header{
      text-align:center;
      padding:15px 0;
      margin-bottom:20px;
      position:sticky;top:0;
      background-color:var(--background-color);
      z-index:10
    }
    h1{font-size:24px;margin:0;font-weight:600}
    .canvas-container{
      position:relative;width:100%;
      max-width:800px;
      margin:0 auto 20px;
      box-shadow:0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -1px rgba(0,0,0,.06);
      border-radius:var(--border-radius);overflow:visible;
      height:auto;min-height:300px
    }
    canvas{
      display:block;
      width:100%;
      height:auto;
      border-radius:var(--border-radius);touch-action:none
    }
    .file-input-wrapper{
      display:flex;width:100%;
      flex-direction:column;
      gap:10px
    }
    .section{
      background-color:#fff;
      padding:20px;
      margin-bottom:20px;
      border-radius:var(--border-radius);
      box-shadow:0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -1px rgba(0,0,0,.06)
    }
    .section-title{
      font-size:18px;
      font-weight:600;
      margin-top:0;
      margin-bottom:15px;
      padding-bottom:10px;
      border-bottom:1px solid var(--border-color)
    }
    .slider-container{margin-bottom:15px}
    .slider-label{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:8px;
      font-weight:500
    }
    .slider-value{
      font-family:monospace;
      background-color:var(--background-color);
      padding:5px 8px;
      border-radius:5px;
      font-weight:400
    }
    input[type=range]{
      -webkit-appearance:none;
      appearance:none;
      width:100%;
      height:10px;
      border-radius:5px;
      background-color:#e2e8f0;
      outline:0;
      transition:background .2s
    }
    input[type=range]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:26px;
      height:26px;
      border-radius:50%;
      background:var(--primary-color);
      cursor:pointer;
      border:2px solid #fff;
      box-shadow:0 2px 4px rgba(0,0,0,.2);
      transition:background .2s
    }
    input[type=range]::-webkit-slider-thumb:active{
      background:var(--primary-dark);
      transform:scale(1.1)
    }
    .button-row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:15px;
      margin-bottom:5px
    }
    button{
      -webkit-appearance:none;
      appearance:none;
      background-color:var(--primary-color);
      color:#fff;
      border:none;
      padding:12px 20px;
      font-size:16px;
      font-weight:500;
      border-radius:var(--border-radius);
      cursor:pointer;
      flex:1 0 auto;
      min-width:120px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      transition:all .2s;
      box-shadow:0 1px 3px rgba(0,0,0,.1)
    }
    button:active{background-color:var(--primary-dark);transform:translateY(1px)}
    button:disabled{opacity:.6;cursor:not-allowed}
    .btn-secondary{background-color:var(--secondary-color)}
    .btn-secondary:active{background-color:var(--secondary-dark)}
    .btn-danger{background-color:var(--danger-color)}
    .btn-danger:active{background-color:var(--danger-dark)}
    .btn-outline{background-color:transparent;color:var(--primary-color);border:2px solid var(--primary-color)}
    .btn-outline:active{background-color:rgba(59,130,246,.1)}
    .btn-icon{width:44px;min-width:auto;padding:10px}
    .plot-container{width:100%;height:300px;margin-top:20px;margin-bottom:10px}
    .calibration-form{display:flex;gap:10px;margin-bottom:15px;flex-wrap:wrap}
    .calibration-input{flex:1;min-width:180px;display:flex;align-items:center}
    input[type=number]{
      display:block;width:100%;
      padding:12px;
      border:1px solid var(--border-color);
      border-radius:var(--border-radius);
      font-size:16px;background-color:#fff
    }
    input[type=number]:focus{outline:0;border-color:var(--primary-color);box-shadow:0 0 0 2px rgba(59,130,246,.3)}
    input[type=file]{display:none}
    .file-label{
      display:inline-flex;
      padding:12px 20px;
      background-color:var(--secondary-color);color:#fff;
      border-radius:var(--border-radius);
      cursor:pointer;font-weight:500;
      text-align:center;flex:1;
      box-shadow:0 1px 3px rgba(0,0,0,.1);align-items:center;
      justify-content:center;gap:8px
    }
    .file-label:active{background-color:var(--secondary-dark);transform:translateY(1px)}
    .file-name{margin-top:8px;font-size:14px;color:#64748b;word-break:break-all}
    label{display:block;margin-bottom:5px;font-weight:500}
    table{width:100%;border-collapse:collapse;margin-bottom:15px}
    table td,table th{padding:12px 10px;text-align:center;border:1px solid var(--border-color)}
    table th{background-color:#f1f5f9;font-weight:600}
    table tr:nth-child(even){background-color:#f8fafc}
    .cal-result{padding:10px;background-color:#f1f5f9;border-radius:var(--border-radius);font-weight:500;text-align:center;margin-bottom:15px}
    .empty-state{text-align:center;padding:30px 20px;color:#64748b}
    .empty-state svg{width:60px;height:60px;margin-bottom:15px;color:#94a3b8}
    .empty-state h3{margin:0 0 10px;font-weight:600;color:var(--text-color)}
    .empty-state p{margin:0}
    
    /*@media only screen and (min-width:768px){.container{padding:20px;max-width:1000px}
    .plot-container{height:400px}
    button{padding:12px 24px}}
    @media only screen and (min-width:1024px){.container{padding:30px}
    .canvas-container{max-height:none}}
    @media (prefers-color-scheme:dark){:root{--background-color:#0f172a;--text-color:#f8fafc;--border-color:#334155}
    .section{background-color:#1e293b}
    input[type=range]{background-color:#334155}
    input[type=number]{background-color:#1e293b;color:var(--text-color)}
    table th{background-color:#334155}
    table tr:nth-child(even){background-color:#1e293b}
    .cal-result{background-color:#334155}
    .slider-value{background-color:#1e293b}
    .file-name{color:#94a3b8}} */

  .file-input-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center; /* 水平置中 */
    width: 100%;
    gap: 10px;
  }
  .file-input-wrapper > div {
    display: flex;
    justify-content: center; /* 水平置中 */
    width: 100%;
  }
  .file-input-wrapper .file-label {
    display: inline-flex;
    max-width: 250px; /* 可選：限制最大寬度 */
    justify-content: center; /* 按鈕內容置中 */
  }
  .pixel-adjust-buttons {
    display: inline-flex;
    margin-left: 10px;
  }

  .pixel-btn {
    width: 30px;
    height: 30px;
    min-width: auto;
    padding: 0;
    margin: 0 2px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: bold;
    border-radius: 50%;
  }
  </style>
  <!-- PWA 基本元標籤 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  
  <!-- 引用 manifest.json -->
  <link rel="manifest" href="./manifest.json">

  <!-- 引用 Service Worker 註冊腳本 -->
  <script src="./sw-register.js"></script>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>📱 光譜分析</h1>
    </div>
    
    <div class="section">
      <h2 class="section-title">圖像輸入</h2>
      
      <div id="imageEmptyState" class="empty-state">
        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M4 16L8.586 11.414C8.96106 11.0391 9.46967 10.8284 10 10.8284C10.5303 10.8284 11.0389 11.0391 11.414 11.414L16 16M14 14L15.586 12.414C15.9611 12.0391 16.4697 11.8284 17 11.8284C17.5303 11.8284 18.0389 12.0391 18.414 12.414L20 14M14 8H14.01M6 20H18C19.1046 20 20 19.1046 20 18V6C20 4.89543 19.1046 4 18 4H6C4.89543 4 4 4.89543 4 6V18C4 19.1046 4.89543 20 6 20Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <h3>尚未添加圖像</h3>
        <p>請上傳光譜圖像以進行分析</p>
      </div>
      
      <div class="file-input-wrapper">
        <div style="margin-bottom:15px;">
          <label for="imgInput" class="file-label">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M4 16L8.586 11.414C8.96106 11.0391 9.46967 10.8284 10 10.8284C10.5303 10.8284 11.0389 11.0391 11.414 11.414L16 16M14 14L15.586 12.414C15.9611 12.0391 16.4697 11.8284 17 11.8284C17.5303 11.8284 18.0389 12.0391 18.414 12.414L20 14M14 8H14.01M6 20H18C19.1046 20 20 19.1046 20 18V6C20 4.89543 19.1046 4 18 4H6C4.89543 4 4 4.89543 4 6V18C4 19.1046 4.89543 20 6 20Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            選擇光譜圖像
          </label>
          <input type="file" id="imgInput" accept="image/*" />
        </div>
        <div id="imageFileName" class="file-name"></div>
      </div>
      
      <div class="canvas-container" style="display:none;">
        <canvas id="preview" touch-action="none"></canvas>
      </div>
    </div>
    
    <div class="section">
      <h2 class="section-title">選擇區域</h2>
      
      <div class="slider-container">
        <div class="slider-label">X 起點 <span class="slider-value" id="xStartVal">00000</span></div>
        <input type="range" id="xStart" min="0" max="100" value="0" />
      </div>
      
      <div class="slider-container">
        <div class="slider-label">X 終點 <span class="slider-value" id="xEndVal">00100</span></div>
        <input type="range" id="xEnd" min="0" max="100" value="100" />
      </div>
      
      <div class="button-row">
        <button id="analyzeBtn" class="btn-primary" disabled>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M9 17L15 11L9 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          分析光譜
        </button>
      </div>
      
      <div id="plotEmptyState" class="empty-state">
        <svg viewBox="0 0 24 24" fill="none">
          <path d="M21 21H3V3M20 7L14 13L10 9L4 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <h3>尚未產生圖表</h3>
        <p>載入圖像後，設定範圍並點擊分析按鈕</p>
      </div>
      
      <div id="plotContainer" style="display:none;">
        <div id="plot" class="plot-container"></div>
      </div>
    </div>
    
    <div class="section">
      <h2 class="section-title">波長校正</h2>
      
      <div class="slider-container">
        <div class="slider-label">
          🎯 校正畫素 <span class="slider-value" id="xCalibrateVal">00050</span>
          <div class="pixel-adjust-buttons">
            <button id="decreasePixelBtn" class="pixel-btn">-</button>
            <button id="increasePixelBtn" class="pixel-btn">+</button>
          </div>
        </div>
        <input type="range" id="xCalibrate" min="0" max="100" value="50" />
      </div>
      
      <div class="calibration-form">
        <div class="calibration-input">
          <label for="wavelengthInput">對應波長 (nm)</label>
          <input type="number" id="wavelengthInput" inputmode="decimal" />
        </div>
        
        <button id="addPointBtn" class="btn-primary" disabled>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M12 4V20M4 12H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          加入校正點
        </button>
      </div>
      
      <div style="margin-top:20px;">
        <table id="calibrationTable">
          <thead>
            <tr>
              <th>#</th>
              <th>畫素位置</th>
              <th>波長 (nm)</th>
              <th>操作</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      
      <div class="button-row">
        <button id="generateRegressionBtn" class="btn-secondary" disabled>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M7 15L12 10L17 15M3 10L12 3L21 10M3 21H21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          產生校正回歸線
        </button>
      </div>
      
      <div class="cal-result" id="regressionResult">尚未校正</div>
    </div>
    
    <div class="section">
      <h2 class="section-title">波長強度圖</h2>
      
      <div id="wavelengthPlotEmptyState" class="empty-state">
        <svg viewBox="0 0 24 24" fill="none">
          <path d="M21 21H3V3M20 7L14 13L10 9L4 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <h3>尚未產生波長強度圖</h3>
        <p>完成校正後，點擊顯示強度-波長圖按鈕</p>
      </div>
      
      <div id="wavelengthPlotContainer" style="display:none;">
        <div id="wavelengthPlot" class="plot-container"></div>
      </div>
      
      <div class="button-row">
        <button id="plotWavelengthBtn" class="btn-primary" disabled>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M21 21H3V3M20 7L14 13L10 9L4 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          顯示強度－波長圖
        </button>
        <button id="toggleBackgroundBtn" class="btn-outline" disabled>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M4 16L8.586 11.414C8.96106 11.0391 9.46967 10.8284 10 10.8284C10.5303 10.8284 11.0389 11.0391 11.414 11.414L16 16M14 14L15.586 12.414C15.9611 12.0391 16.4697 11.8284 17 11.8284C17.5303 11.8284 18.0389 12.0391 18.414 12.414L20 14M14 8H14.01M6 20H18C19.1046 20 20 19.1046 20 18V6C20 4.89543 19.1046 4 18 4H6C4.89543 4 4 4.89543 4 6V18C4 19.1046 4.89543 20 6 20Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          加入背景圖
        </button>
      </div>
      
      <div class="button-row" style="margin-top:15px;">
        <button id="exportParamsBtn" class="btn-secondary" disabled>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M3 15C3 17.8284 3 19.2426 3.87868 20.1213C4.75736 21 6.17157 21 9 21H15C17.8284 21 19.2426 21 20.1213 20.1213C21 19.2426 21 17.8284 21 15M12 3L12 15M12 15L16 11M12 15L8 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          匯出分析參數
        </button>
      </div>
      
      <div id="exportedParams" style="margin-top:15px;padding:10px;background-color:#f1f5f9;border-radius:8px;font-family:monospace;display:none;word-break:break-all;"></div>
    </div>
  </div>

  <script>
    // DOM元素與全局變量
    const el = id => document.getElementById(id),
          canvas = el("preview"),
          ctx = canvas.getContext("2d", {alpha: false}),
          img = new Image();
    
    const elems = {
      imgInput: el("imgInput"),
      fileName: el("imageFileName"),
      emptyState: el("imageEmptyState"),
      canvasContainer: document.querySelector(".canvas-container"),
      xStart: el("xStart"),
      xEnd: el("xEnd"),
      xCalibrate: el("xCalibrate"),
      xStartVal: el("xStartVal"),
      xEndVal: el("xEndVal"),
      xCalibrateVal: el("xCalibrateVal"),
      wavelengthInput: el("wavelengthInput"),
      analyzeBtn: el("analyzeBtn"),
      addPointBtn: el("addPointBtn"),
      genRegressionBtn: el("generateRegressionBtn"),
      plotWaveBtn: el("plotWavelengthBtn"),
      toggleBgBtn: el("toggleBackgroundBtn"),
      exportBtn: el("exportParamsBtn"),
      regressResult: el("regressionResult"),
      plotEmpty: el("plotEmptyState"),
      plotCtr: el("plotContainer"),
      waveplotEmpty: el("wavelengthPlotEmptyState"),
      waveplotCtr: el("wavelengthPlotContainer"),
      exportedParams: el("exportedParams")
    };
    
    let calibPoints = [],
        calibration = null,
        regressConfirmed = false,
        imageData, rawData, width, height,
        bgImageOn = false,
        gestureDetected = false,
        lastTouchDist = 0,
        touchStartX = 0,
        canvasDims = {offsetX: 0, offsetY: 0, drawWidth: 0, drawHeight: 0};
    
    // 設置畫布
    function setupCanvas() {
      const dpr = window.devicePixelRatio || 1,
            container = canvas.parentElement,
            containerWidth = container.clientWidth;
      
      // 計算畫布尺寸
      let canvasW = containerWidth, 
          canvasH = containerWidth * 0.75;
      
      // 如果有照片，根據照片比例調整
      if (img.complete && img.naturalWidth > 0) {
        const imgRatio = img.naturalWidth / img.naturalHeight;
        canvasH = containerWidth / imgRatio;
        
        // 設定高度限制
        canvasH = Math.min(Math.max(canvasH, containerWidth * 0.5), containerWidth * 1.2);
      }
      
      // 設置畫布尺寸
      canvas.width = canvasW * dpr;
      canvas.height = canvasH * dpr;
      canvas.style.width = `${canvasW}px`;
      canvas.style.height = `${canvasH}px`;
      
      // 調整繪圖上下文
      ctx.scale(dpr, dpr);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      
      // 調整容器
      container.style.height = `${canvasH}px`;
      container.style.overflow = 'visible';
      container.style.maxHeight = 'none';
    }
    
    // 繪製圖像
    function drawImage() {
      if (!img.complete || !img.naturalWidth) return;
      
      const dpr = window.devicePixelRatio || 1,
            canvasW = canvas.width / dpr,
            canvasH = canvas.height / dpr,
            imgRatio = img.naturalWidth / img.naturalHeight,
            canvasRatio = canvasW / canvasH;
      
      let drawW, drawH, offsetX = 0, offsetY = 0;
      
      if (imgRatio > canvasRatio) {
        drawW = canvasW;
        drawH = canvasW / imgRatio;
        offsetY = (canvasH - drawH) / 2;
      } else {
        drawH = canvasH;
        drawW = canvasH * imgRatio;
        offsetX = (canvasW - drawW) / 2;
      }
      
      ctx.clearRect(0, 0, canvasW, canvasH);
      ctx.drawImage(img, offsetX, offsetY, drawW, drawH);
      
      canvasDims = {offsetX, offsetY, drawWidth: drawW, drawHeight: drawH};
      return canvasDims;
    }
    
    // 更新滑桿
    function updateSliders(max) {
      [elems.xStart, elems.xEnd, elems.xCalibrate].forEach(s => s.max = max);
      elems.xStart.value = 0;
      elems.xEnd.value = max;
      elems.xCalibrate.value = Math.floor(max / 2);
      syncSliderValues();
    }
    
    // 同步滑桿值
    function syncSliderValues() {
      let x1 = parseInt(elems.xStart.value),
          x2 = parseInt(elems.xEnd.value);
      
      if (x2 < x1) [x1, x2] = [x2, x1];
      
      elems.xStartVal.textContent = x1.toString().padStart(5, "0");
      elems.xEndVal.textContent = x2.toString().padStart(5, "0");
      elems.xCalibrateVal.textContent = elems.xCalibrate.value.toString().padStart(5, "0");
      
      elems.xCalibrate.min = x1;
      elems.xCalibrate.max = x2;
      
      requestAnimationFrame(drawWithRect);
    }
    
    // 繪製方框
    function drawWithRect() {
      if (!img.complete || !img.naturalWidth) return;
      
      const dpr = window.devicePixelRatio || 1,
            canvasW = canvas.width / dpr,
            canvasH = canvas.height / dpr;
      
      ctx.clearRect(0, 0, canvasW, canvasH);
      const {offsetX, offsetY, drawWidth, drawHeight} = drawImage();
      
      let x1 = parseInt(elems.xStart.value),
          x2 = parseInt(elems.xEnd.value);
      
      if (x2 < x1) [x1, x2] = [x2, x1];
      
      // 計算比例
      const xScale = drawWidth / width,
            yScale = drawHeight / height,
            rectX1 = Math.floor(offsetX + x1 * xScale) + 0.5,
            rectX2 = Math.floor(offsetX + x2 * xScale) + 0.5,
            rectY1 = Math.floor(offsetY + height * 0.45 * yScale) + 0.5,
            rectY2 = Math.floor(offsetY + height * 0.55 * yScale) + 0.5;
      
      // 繪製矩形
      ctx.strokeStyle = "yellow";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(rectX1, rectY1);
      ctx.lineTo(rectX2, rectY1);
      ctx.lineTo(rectX2, rectY2);
      ctx.lineTo(rectX1, rectY2);
      ctx.closePath();
      ctx.stroke();
    }
    
    // 提取和繪製強度圖
    function extractAndPlot() {
      if (!rawData) {
        notify("請先上傳圖片！");
        return;
      }
      
      // 獲取選定範圍
      let x1 = parseInt(elems.xStart.value),
          x2 = parseInt(elems.xEnd.value);
      
      if (x2 < x1) [x1, x2] = [x2, x1];
      
      const y1 = Math.floor(height * 0.45) + 2,
            y2 = Math.floor(height * 0.55) - 2,
            dataX = [], 
            dataY = [];
      
      // 計算平均強度
      for (let x = x1; x <= x2; x++) {
        let sum = 0;
        for (let y = y1; y <= y2; y++) {
          const idx = (y * width + x) * 4;
          if (idx < rawData.length) {
            sum += (rawData[idx] + rawData[idx + 1] + rawData[idx + 2]) / 3;
          }
        }
        dataX.push(x);
        dataY.push(sum / (y2 - y1 + 1));
      }
      
      // 繪製標記線
      const shapes = [{
        type: "line",
        x0: parseInt(elems.xCalibrate.value),
        x1: parseInt(elems.xCalibrate.value),
        y0: 0,
        y1: Math.max(...dataY),
        line: {color: "red", width: 2, dash: "dot"}
      }];
      
      // 顯示圖表
      elems.plotEmpty.style.display = "none";
      elems.plotCtr.style.display = "block";
      
      // 更新或創建圖表
      const plotEl = document.getElementById('plot');
      if (plotEl.data && plotEl.data.length > 0) {
        Plotly.update('plot', {x: [dataX], y: [dataY]}, {shapes});
      } else {
        Plotly.newPlot("plot", [{
          x: dataX,
          y: dataY,
          mode: "lines",
          name: "像素強度",
          line: {color: "#3b82f6", width: 3}
        }], {
          margin: {t: 20, r: 20, b: 40, l: 50},
          xaxis: {
            title: "像素位置",
            showline: true,
            mirror: true,
            ticks: 'outside',
            linecolor: 'black',
            linewidth: 2,
            tickfont: {size: 14}
          },
          yaxis: {
            title: "強度",
            showline: true,
            mirror: true,
            ticks: 'outside',
            linecolor: 'black',
            linewidth: 2,
            tickfont: {size: 14}
          },
          shapes: shapes,
          dragmode: 'pan',
          modeBarButtonsToAdd: [
            'hoverClosestCartesian',
            'hoverCompareCartesian',
            'toggleSpikelines'
          ],
          hovermode: 'closest',
          colorway: ['#3b82f6', '#ef4444', '#22c55e'],
          plot_bgcolor: 'rgba(255,255,255)',
          paper_bgcolor: 'rgba(255,255,255)'
        }, {
          displayModeBar: true,
          responsive: true,
          toImageButtonOptions: {
            format: 'png',
            filename: 'spectrum_intensity.png', // 添加副檔名
            scale: 2
          },
          modeBarButtonsToRemove: [
            'lasso2d',
            'select2d',
            'autoScale2d'
          ]
        });
      }
      
      // 啟用校正按鈕
      elems.addPointBtn.disabled = false;

      // 在創建圖表後設置自定義下載按鈕
      setTimeout(() => setupCustomDownloadButton('plot', 'spectrum_intensity.png'), 500);
    }
    
    // 更新校正表格
    function updateCalibTable() {
      const tbody = document.querySelector("#calibrationTable tbody");
      tbody.innerHTML = "";
      
      calibPoints.forEach((p, i) => {
        const row = document.createElement("tr");
        
        // 建立單元格
        const cells = [
          {text: i + 1},
          {text: p.pixel},
          {text: p.wavelength.toFixed(2)},
          {html: createDeleteBtn(i)}
        ];
        
        cells.forEach(cell => {
          const td = document.createElement("td");
          if (cell.text !== undefined) td.textContent = cell.text;
          if (cell.html) td.appendChild(cell.html);
          row.appendChild(td);
        });
        
        tbody.appendChild(row);
      });
      
      // 更新回歸按鈕狀態
      elems.genRegressionBtn.disabled = calibPoints.length < 2;
    }
    
    // 創建刪除按鈕
    function createDeleteBtn(index) {
      const btn = document.createElement("button");
      btn.textContent = "❌";
      btn.classList.add("btn-icon");
      btn.style.margin = "0 auto";
      btn.style.display = "block";
      btn.style.backgroundColor = "white";
      btn.style.border = "2px solid #ef4444";
      btn.style.color = "#ef4444";
      btn.style.width = "36px";
      btn.style.height = "36px";
      btn.style.padding = "0";
      btn.style.minWidth = "auto";
      
      btn.onclick = e => {
        e.preventDefault();
        calibPoints.splice(index, 1);
        regressConfirmed = false;
        calibration = null;
        elems.regressResult.textContent = "尚未校正";
        updateCalibTable();
        updateButtonStates();
      };
      
      return btn;
    }
    
    // 獲取選定範圍的圖像數據URL
    function getSelectedImageURL(x1, x2, y1, y2) {
      const cropCanvas = document.createElement("canvas"),
            cropCtx = cropCanvas.getContext("2d"),
            cropWidth = x2 - x1 + 1,
            cropHeight = y2 - y1 + 1;
      
      cropCanvas.width = cropWidth;
      cropCanvas.height = cropHeight;
      
      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = width;
      tempCanvas.height = height;
      const tempCtx = tempCanvas.getContext("2d");
      tempCtx.putImageData(imageData, 0, 0);
      
      try {
        const cropImageData = tempCtx.getImageData(x1, y1, cropWidth, cropHeight);
        cropCtx.putImageData(cropImageData, 0, 0);
        return cropCanvas.toDataURL();
      } catch (e) {
        console.error("裁剪圖像發生錯誤:", e);
        return null;
      }
    }
    
    // 繪製波長強度圖
    function plotWavelengthGraph() {
      if (!rawData) {
        notify("請先上傳圖片！");
        return;
      }
      
      if (!calibration) {
        notify("請先加入至少兩個校正點，並完成校正！", "error");
        return;
      }
      
      // 獲取資料
      let x1 = parseInt(elems.xStart.value),
          x2 = parseInt(elems.xEnd.value);
      
      if (x2 < x1) [x1, x2] = [x2, x1];
      
      const y1 = Math.floor(height * 0.45) + 2,
            y2 = Math.floor(height * 0.55) - 2,
            dataX = [],
            dataY = [];
      
      // 計算強度
      for (let x = x1; x <= x2; x++) {
        let sum = 0;
        for (let y = y1; y <= y2; y++) {
          const idx = (y * width + x) * 4;
          if (idx < rawData.length) {
            sum += (rawData[idx] + rawData[idx + 1] + rawData[idx + 2]) / 3;
          }
        }
        dataX.push(x);
        dataY.push(sum / (y2 - y1 + 1));
      }
      
      // 轉換為波長
      const {a, b} = calibration;
      const wavelengthX = dataX.map(x => a * x + b);
      
      // 顯示圖表
      elems.waveplotEmpty.style.display = "none";
      elems.waveplotCtr.style.display = "block";
      
      // 建立圖表
      Plotly.newPlot("wavelengthPlot", [{
        x: wavelengthX,
        y: dataY,
        mode: "lines",
        name: "波長強度",
        line: {color: "#22c55e", width: 3}
      }], {
        margin: {t: 20, r: 20, b: 40, l: 50},
        xaxis: {
          title: "波長 (nm)",
          showline: true,
          mirror: true,
          ticks: 'outside',
          linecolor: 'black',
          linewidth: 2,
          tickfont: {size: 14}
        },
        yaxis: {
          title: "強度",
          showline: true,
          mirror: true,
          ticks: 'outside',
          linecolor: 'black',
          linewidth: 2,
          tickfont: {size: 14}
        },
        dragmode: 'pan',
        modeBarButtonsToAdd: [
          'hoverClosestCartesian',
          'hoverCompareCartesian',
          'toggleSpikelines'
        ],
        hovermode: 'closest',
        images: [],
        plot_bgcolor: 'rgba(255,255,255)',
        paper_bgcolor: 'rgba(255,255,255)'
      }, {
        displayModeBar: true,
        responsive: true,
        toImageButtonOptions: {
          format: 'png',
          filename: 'spectrum_wavelength.png', // 添加副檔名
          scale: 2
        },
        modeBarButtonsToRemove: [
          'lasso2d',
          'select2d',
          'autoScale2d'
        ]
      });
      
     // 更新按鈕狀態
    elems.toggleBgBtn.disabled = false;
    bgImageOn = false;
    elems.toggleBgBtn.textContent = "🖼 加入背景圖";
    elems.toggleBgBtn.classList.add("btn-outline");
    elems.toggleBgBtn.classList.remove("btn-danger");
    elems.exportBtn.disabled = false;

    // 在創建圖表後設置自定義下載按鈕
    setTimeout(() => setupCustomDownloadButton('wavelengthPlot', 'spectrum_wavelength.png'), 500);
    }
    
    // 切換背景圖
    function toggleBackground() {
      if (!rawData || !calibration) {
        notify("請先加入至少兩個校正點，並完成校正！", "error");
        return;
      }
      
      // 獲取範圍
      let x1 = parseInt(elems.xStart.value),
          x2 = parseInt(elems.xEnd.value);
      
      if (x2 < x1) [x1, x2] = [x2, x1];
      
      const y1 = Math.floor(height * 0.45) + 2,
            y2 = Math.floor(height * 0.55) - 2,
            {a, b} = calibration,
            wlStart = a * x1 + b,
            wlEnd = a * x2 + b;
      
      if (!bgImageOn) {
        // 加入背景圖
        const imageDataUrl = getSelectedImageURL(x1, x2, y1, y2);
        
        if (imageDataUrl) {
          Plotly.relayout("wavelengthPlot", {
            images: [{
              source: imageDataUrl,
              xref: "x",
              yref: "paper",
              x: wlStart,
              y: 1,
              sizex: wlEnd - wlStart,
              sizey: 1,
              sizing: "stretch",
              opacity: 0.6,
              layer: "below"
            }]
          });
          
          bgImageOn = true;
          elems.toggleBgBtn.textContent = "🚫 移除背景圖";
          elems.toggleBgBtn.classList.remove("btn-outline");
          elems.toggleBgBtn.classList.add("btn-danger");
        } else {
          notify("無法生成背景圖片，請檢查選擇範圍！", "error");
        }
      } else {
        // 移除背景圖
        Plotly.relayout("wavelengthPlot", {images: []});
        
        bgImageOn = false;
        elems.toggleBgBtn.textContent = "🖼 加入背景圖";
        elems.toggleBgBtn.classList.add("btn-outline");
        elems.toggleBgBtn.classList.remove("btn-danger");
      }
      // 在創建圖表後設置自定義下載按鈕
      setTimeout(() => setupCustomDownloadButton('wavelengthPlot', 'spectrum_wavelength.png'), 500);
    }
    
    // 圖片加載處理
    function loadImage(file) {
      if (!file) return;
      
      // 重置數據
      resetData();
      
      // 顯示文件名
      elems.fileName.textContent = file.name;
      
      const reader = new FileReader();
      
      reader.onload = e => {
        img.onload = () => {
          // 設置圖片尺寸
          width = img.naturalWidth;
          height = img.naturalHeight;
          
          // 更新界面
          elems.emptyState.style.display = 'none';
          
          // 設置畫布容器
          elems.canvasContainer.style.display = 'block';
          elems.canvasContainer.style.overflow = 'visible';
          elems.canvasContainer.style.height = 'auto';
          elems.canvasContainer.style.maxHeight = 'none';
          
          // 設置畫布
          setupCanvas();
          updateSliders(width - 1);
          
          // 處理圖片
          (img.decode ? img.decode() : Promise.resolve())
            .then(processImage)
            .catch(err => {
              console.error("圖片解碼失敗:", err);
              processImage();
            });
        };
        
        img.src = e.target.result;
      };
      
      reader.readAsDataURL(file);
    }
    
    // 重置數據
    function resetData() {
      calibPoints = [];
      calibration = null;
      regressConfirmed = false;
      elems.regressResult.textContent = "尚未校正";
      updateCalibTable();

      Plotly.purge("plot");
      Plotly.purge("wavelengthPlot");

      elems.plotEmpty.style.display = "block";
      elems.plotCtr.style.display = "none";
      elems.waveplotEmpty.style.display = "block";
      elems.waveplotCtr.style.display = "none";

      bgImageOn = false;
      elems.toggleBgBtn.textContent = "🖼 加入背景圖";
      elems.toggleBgBtn.classList.add("btn-outline");
      elems.toggleBgBtn.classList.remove("btn-danger");

      elems.wavelengthInput.value = "";

      // 🔽 新增這一段
      elems.exportedParams.innerHTML = "";
      elems.exportedParams.style.display = "none";

      elems.xStartVal.textContent = "00000";
      elems.xEndVal.textContent = "00100";
      elems.xCalibrateVal.textContent = "00050";

      elems.xStart.value = 0;
      elems.xEnd.value = width - 1;
      elems.xCalibrate.value = Math.floor((width - 1) / 2);

      const tbody = document.querySelector("#calibrationTable tbody");
      tbody.innerHTML = "";

      elems.exportBtn.disabled = true;

      updateButtonStates();
    }

    
    // 更新按鈕狀態
    function updateButtonStates() {
      const hasImage = img.complete && img.naturalWidth > 0,
            hasAnalyzed = elems.plotCtr.style.display === "block",
            hasCalibration = calibration !== null && regressConfirmed;
      
      elems.analyzeBtn.disabled = !hasImage;
      elems.addPointBtn.disabled = !hasAnalyzed;
      elems.genRegressionBtn.disabled = calibPoints.length < 2;
      elems.plotWaveBtn.disabled = !hasCalibration;
      elems.toggleBgBtn.disabled = !hasCalibration || elems.waveplotCtr.style.display === "none";
      elems.exportBtn.disabled = !hasCalibration;
    }
    
    // 處理圖片
    function processImage() {
      // 創建臨時畫布獲取像素數據
      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = width;
      tempCanvas.height = height;
      const tempCtx = tempCanvas.getContext("2d");
      tempCtx.drawImage(img, 0, 0);
      
      try {
        imageData = tempCtx.getImageData(0, 0, width, height);
        rawData = imageData.data;
        
        drawWithRect();
        notify("圖片已成功載入", "success");
        
        // 啟用分析按鈕
        elems.analyzeBtn.disabled = false;
      } catch (e) {
        console.error("處理圖片時發生錯誤:", e);
        notify("圖片處理失敗，請嘗試使用其他圖片。", "error");
      }
    }
    
    // 添加校正點
    function addCalibPoint() {
      const pixel = parseInt(elems.xCalibrate.value),
            wavelength = parseFloat(elems.wavelengthInput.value);
      
      if (isNaN(pixel) || isNaN(wavelength)) {
        notify("請輸入有效的畫素與波長！", "error");
        return;
      }
      
      calibPoints.push({pixel, wavelength});
      regressConfirmed = false;
      calibration = null;
      elems.regressResult.textContent = "尚未校正";
      updateCalibTable();
      notify("已加入校正點", "success");
      elems.wavelengthInput.value = "";
      
      updateButtonStates();
    }
    
    // 生成回歸線
    function generateRegression() {
      if (calibPoints.length < 2) {
        notify("請至少輸入兩個校正點！", "error");
        return;
      }
      
      // 線性回歸
      let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
      const n = calibPoints.length;
      
      calibPoints.forEach(p => {
        sumX += p.pixel;
        sumY += p.wavelength;
        sumXY += p.pixel * p.wavelength;
        sumX2 += p.pixel * p.pixel;
      });
      
      const a = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      const b = (sumY - a * sumX) / n;
      
      calibration = {a, b};
      regressConfirmed = true;
      
      elems.regressResult.textContent = `λ = ${a.toFixed(4)} × x + ${b.toFixed(2)}`;
      notify("已生成校正方程式", "success");
      
      updateButtonStates();
    }
    
    // 匯出分析參數
    function exportParams() {
      if (!rawData || !calibration) {
        notify("請先完成波長校正！", "error");
        return;
      }
      
      // 獲取參數
      const x1 = parseInt(elems.xStart.value),
            x2 = parseInt(elems.xEnd.value),
            {a, b} = calibration,
            params = {
              xStart: x1,
              xEnd: x2,
              wavelengthStart: a * x1 + b,
              wavelengthEnd: a * x2 + b,
              regressionSlope: a,
              regressionIntercept: b,
              calibrationPoints: calibPoints
            };
      
      // 顯示參數
      elems.exportedParams.innerHTML = `<div style="font-weight:bold;margin-bottom:5px;">分析參數：</div>`;
      elems.exportedParams.innerHTML += `X起點: ${params.xStart} (${params.wavelengthStart.toFixed(2)} nm)<br>`;
      elems.exportedParams.innerHTML += `X終點: ${params.xEnd} (${params.wavelengthEnd.toFixed(2)} nm)<br>`;
      elems.exportedParams.innerHTML += `回歸線斜率: ${params.regressionSlope.toFixed(6)}<br>`;
      elems.exportedParams.innerHTML += `回歸線截距: ${params.regressionIntercept.toFixed(6)}<br>`;
      
      // 創建下載按鈕
      const buttonArea = document.createElement("div");
      buttonArea.style.marginTop = "15px";
      buttonArea.style.display = "flex";
      buttonArea.style.justifyContent = "flex-end";
      
      const downloadBtn = document.createElement("button");
      downloadBtn.textContent = "下載CSV";
      downloadBtn.classList.add("btn-secondary");
      downloadBtn.onclick = () => {
        // 建立CSV內容
        let csv = "參數名稱,數值\n";
        csv += `xStart,${params.xStart}\n`;
        csv += `xEnd,${params.xEnd}\n`;
        csv += `wavelengthStart,${params.wavelengthStart.toFixed(6)}\n`;
        csv += `wavelengthEnd,${params.wavelengthEnd.toFixed(6)}\n`;
        csv += `regressionSlope,${params.regressionSlope.toFixed(6)}\n`;
        csv += `regressionIntercept,${params.regressionIntercept.toFixed(6)}\n\n`;
        
        // 添加校正點
        csv += "calibration_index,pixel,wavelength\n";
        params.calibrationPoints.forEach((p, i) => {
          csv += `${i+1},${p.pixel},${p.wavelength.toFixed(6)}\n`;
        });
        
        // 針對 iOS 優化的下載方法
        const filename = "spectrum_parameters.csv";
        const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});

        // 檢測是否為 iOS 裝置
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

        if (isIOS) {
          // iOS 裝置專用下載方法
          const reader = new FileReader();
          reader.onload = function() {
            const link = document.createElement('a');
            link.href = reader.result;
            link.download = filename;
            link.target = '_blank';
            link.rel = 'noopener';
            
            // 設置額外的屬性來幫助識別檔案類型
            link.setAttribute('type', 'text/csv');
            link.setAttribute('data-downloadurl', ['text/csv', filename, link.href].join(':'));
            
            document.body.appendChild(link);
            link.click();
            setTimeout(() => document.body.removeChild(link), 100);
          };
          reader.readAsDataURL(blob);
        } else {
          // 其他裝置的標準下載方法
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = filename;
          link.style.visibility = 'hidden';
          document.body.appendChild(link);
          link.click();
          setTimeout(() => {
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
          }, 100);
        }
        
        notify("CSV檔案已下載", "success");
      };
      
      buttonArea.appendChild(downloadBtn);
      
      // 移除舊按鈕，添加新按鈕
      const oldBtn = document.getElementById("copyParamsBtn");
      if (oldBtn) oldBtn.remove();
      
      elems.exportedParams.appendChild(buttonArea);
      elems.exportedParams.style.display = "block";
      
      notify("已匯出分析參數", "success");
    }
    
    // 顯示通知
    function notify(message, type = "info", duration = 2000) {
      const notification = document.createElement("div");
      notification.textContent = message;
      notification.style.cssText = `
        position:fixed;
        bottom:20px;
        left:50%;
        transform:translateX(-50%);
        padding:12px 20px;
        border-radius:8px;
        font-weight:500;
        box-shadow:0 4px 12px rgba(0,0,0,.15);
        z-index:9999;
        max-width:80%;
        text-align:center;
        background-color:${type === "success" ? "#22c55e" : type === "error" ? "#ef4444" : "#3b82f6"};
        color:white;
      `;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.opacity = "0";
        notification.style.transition = "opacity 0.5s ease";
        setTimeout(() => document.body.removeChild(notification), 500);
      }, duration);
    }
    
    // 設置多點觸控
    function setupGestures() {
      // 觸控開始
      canvas.addEventListener('touchstart', e => {
        if (e.touches.length === 2) {
          // 雙指觸控
          gestureDetected = true;
          const t1 = e.touches[0], t2 = e.touches[1];
          lastTouchDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
          touchStartX = (t1.clientX + t2.clientX) / 2;
        } else if (e.touches.length === 1) {
          // 單指觸控
          touchStartX = e.touches[0].clientX;
        }
        e.preventDefault();
      }, {passive: false});
      
      // 觸控移動
      canvas.addEventListener('touchmove', e => {
        if (e.touches.length === 2 && gestureDetected) {
          // 雙指手勢
          const t1 = e.touches[0], t2 = e.touches[1];
          const touchDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
          
          // 計算縮放比例
          const scale = touchDist / lastTouchDist;
          lastTouchDist = touchDist;
          
          // 計算中心點
          const touchX = (t1.clientX + t2.clientX) / 2;
          const touchDX = touchX - touchStartX;
          touchStartX = touchX;
          
          // 應用操作
          if (Math.abs(scale - 1) > 0.05) {
            // 縮放
            const x1 = parseInt(elems.xStart.value);
            const x2 = parseInt(elems.xEnd.value);
            const range = x2 - x1;
            const mid = (x1 + x2) / 2;
            
            const newRange = Math.max(10, Math.min(width - 1, range * scale));
            const newX1 = Math.max(0, Math.round(mid - newRange / 2));
            const newX2 = Math.min(width - 1, Math.round(mid + newRange / 2));
            
            elems.xStart.value = newX1;
            elems.xEnd.value = newX2;
            syncSliderValues();
          } else if (Math.abs(touchDX) > 5) {
            // 平移
            const x1 = parseInt(elems.xStart.value);
            const x2 = parseInt(elems.xEnd.value);
            const range = x2 - x1;
            
            // 計算移動像素
            const pixelDelta = Math.round(touchDX * width / canvas.clientWidth);
            
            if (Math.abs(pixelDelta) > 0) {
              let newX1 = x1 + pixelDelta;
              let newX2 = x2 + pixelDelta;
              
              // 邊界檢查
              if (newX1 < 0) {
                newX1 = 0;
                newX2 = range;
              }
              
              if (newX2 > width - 1) {
                newX2 = width - 1;
                newX1 = newX2 - range;
              }
              
              elems.xStart.value = newX1;
              elems.xEnd.value = newX2;
              syncSliderValues();
            }
          }
        } else if (e.touches.length === 1 && !gestureDetected) {
          // 單指移動
          const touch = e.touches[0];
          const touchDX = touch.clientX - touchStartX;
          touchStartX = touch.clientX;
          
          // 移動校正點
          const pixelDelta = Math.round(touchDX * width / canvas.clientWidth);
          
          if (Math.abs(pixelDelta) > 0) {
            const newPos = parseInt(elems.xCalibrate.value) + pixelDelta;
            elems.xCalibrate.value = Math.max(elems.xCalibrate.min, Math.min(elems.xCalibrate.max, newPos));
            syncSliderValues();
            if (rawData) extractAndPlot();
          }
        }
        e.preventDefault();
      }, {passive: false});
      
      // 觸控結束
      canvas.addEventListener('touchend', e => {
        gestureDetected = false;
        
        // 更新圖表
        if (e.touches.length === 0 && rawData) extractAndPlot();
      });
      
      // 阻止縮放
      canvas.addEventListener('gesturestart', e => e.preventDefault(), {passive: false});
    }
    
    // 初始化事件監聽
    function setupEvents() {
      // 檔案選擇
      elems.imgInput.addEventListener("change", e => {
        if (e.target.files && e.target.files[0]) {
          loadImage(e.target.files[0]);
          e.target.value = ''; // 重置輸入
        }
      });
      
      // 滑桿事件
      elems.xStart.addEventListener("input", syncSliderValues);
      elems.xEnd.addEventListener("input", syncSliderValues);
      elems.xCalibrate.addEventListener("input", () => {
        syncSliderValues();
        if (rawData) extractAndPlot();
      });
      
      // 按鈕事件
      elems.analyzeBtn.addEventListener("click", extractAndPlot);
      elems.addPointBtn.addEventListener("click", addCalibPoint);
      elems.genRegressionBtn.addEventListener("click", generateRegression);
      elems.plotWaveBtn.addEventListener("click", plotWavelengthGraph);
      elems.toggleBgBtn.addEventListener("click", toggleBackground);
      elems.exportBtn.addEventListener("click", exportParams);
      
      // 為像素調整按鈕添加事件監聽
      document.getElementById('decreasePixelBtn').addEventListener('click', () => {
        const calibrateEl = elems.xCalibrate;
        const currentValue = parseInt(calibrateEl.value);
        const newValue = Math.max(parseInt(calibrateEl.min), currentValue - 1);
        calibrateEl.value = newValue;
        syncSliderValues();
        if (rawData) extractAndPlot();
      });

      document.getElementById('increasePixelBtn').addEventListener('click', () => {
        const calibrateEl = elems.xCalibrate;
        const currentValue = parseInt(calibrateEl.value);
        const newValue = Math.min(parseInt(calibrateEl.max), currentValue + 1);
        calibrateEl.value = newValue;
        syncSliderValues();
        if (rawData) extractAndPlot();
      });
      // 波長輸入回車
      elems.wavelengthInput.addEventListener("keydown", e => {
        if (e.key === "Enter") {
          e.preventDefault();
          addCalibPoint();
        }
      });
      
      // 窗口調整大小
      window.addEventListener('resize', () => {
        if (img.complete && img.naturalWidth > 0) {
          setupCanvas();
          requestAnimationFrame(drawWithRect);
        }
      });
      
      // 禁用頁面縮放
      document.addEventListener('gesturestart', e => e.preventDefault(), {passive: false});
      document.addEventListener('gesturechange', e => e.preventDefault(), {passive: false});
    }
    
    // 初始化應用
    function init() {
      // 設置畫布容器樣式
      if (elems.canvasContainer) {
        elems.canvasContainer.style.overflow = 'visible';
        elems.canvasContainer.style.height = 'auto';
        elems.canvasContainer.style.minHeight = '300px';
        elems.canvasContainer.style.maxHeight = 'none';
      }
      
      setupCanvas();
      setupEvents();
      setupGestures();
      updateButtonStates();
      
      // 顯示版本信息
      const versionDiv = document.createElement('div');
      versionDiv.style.cssText = 'text-align:center;margin-top:20px;font-size:12px;color:#666;';
      versionDiv.innerHTML = '光譜分析工具 v1.8 - 檔案下載優化版';
      document.querySelector('.container').appendChild(versionDiv);
    }

    function setupCustomDownloadButton(plotId, filename = 'spectrum.png') {
      const modebar = document.querySelector(`#${plotId} .modebar`);
      if (!modebar) return;

      const downloadBtn = modebar.querySelector(".modebar-btn[data-title='Download plot as a png']");
      if (!downloadBtn) return;

      // 先移除原本 onclick
      downloadBtn.onclick = null;

      // 改成手動處理下載
      downloadBtn.addEventListener("click", async (e) => {
        e.preventDefault();
        try {
          // 先暫時設定白色背景用於下載
          Plotly.relayout(plotId, {
            plot_bgcolor: 'rgb(255,255,255)',
            paper_bgcolor: 'rgb(255,255,255)'
          });
          
          const dataUrl = await Plotly.toImage(plotId, {
            format: "png",
            height: 600,
            width: 800,
            scale: 2
          });

          const link = document.createElement("a");
          link.href = dataUrl;
          link.download = filename; // 🔥 指定明確的副檔名
          link.target = "_blank";
          link.rel = "noopener";

          // iOS 特別處理：使用 data URL 開啟新頁籤比較穩
          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
          if (isIOS) {
            const win = window.open();
            win.document.write(`<html><body style="margin:0;"><img src="${dataUrl}" style="width:100%;"/></body></html>`);
          } else {
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          }

        } catch (err) {
          console.error("下載圖像失敗：", err);
          notify("圖像下載失敗", "error");
        }
      });
    }

    // 啟動應用
    init();


  </script>
</body>
</html>
