<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>iPadÂÖâË≠úÂàÜÊûêÂ∑•ÂÖ∑</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    :root {
      --primary-color: #3b82f6;
      --primary-dark: #2563eb;
      --secondary-color: #22c55e;
      --secondary-dark: #16a34a;
      --danger-color: #ef4444;
      --danger-dark: #dc2626;
      --background-color: #f8fafc;
      --text-color: #0f172a;
      --border-color: #cbd5e1;
      --border-radius: 10px;
      --safe-area-inset-top: env(safe-area-inset-top, 0px);
      --safe-area-inset-bottom: env(safe-area-inset-bottom, 20px);
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 0;
      background-color: var(--background-color);
      color: var(--text-color);
      overscroll-behavior-y: none;
      touch-action: manipulation;
      padding: 0 12px;
      padding-top: calc(var(--safe-area-inset-top) + 12px);
      padding-bottom: calc(var(--safe-area-inset-bottom) + 12px);
    }
    
    .container {
      max-width: 100%;
      margin: 0 auto;
      padding-bottom: 30px;
    }
    
    .header {
      text-align: center;
      padding: 15px 0;
      margin-bottom: 20px;
      position: sticky;
      top: 0;
      background-color: var(--background-color);
      z-index: 10;
    }
    
    h1 {
      font-size: 24px;
      margin: 0;
      font-weight: 600;
    }
    
    .canvas-container {
      position: relative;
      width: 100%;
      max-width: 800px;
      margin: 0 auto 20px auto;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      border-radius: var(--border-radius);
      overflow: hidden;
    }
    
    canvas {
      display: block;
      width: 100%;
      height: auto;
      border-radius: var(--border-radius);
      touch-action: none;
    }
    
    .input-group {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
      gap: 10px;
    }
    
    .file-input-wrapper {
      display: flex;
      width: 100%;
      flex-direction: column;
      gap: 10px;
    }
    
    .file-buttons {
      display: flex;
      gap: 10px;
    }
    
    .section {
      background-color: white;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: var(--border-radius);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    
    .section-title {
      font-size: 18px;
      font-weight: 600;
      margin-top: 0;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .slider-container {
      margin-bottom: 15px;
    }
    
    .slider-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-weight: 500;
    }
    
    .slider-value {
      font-family: monospace;
      background-color: var(--background-color);
      padding: 5px 8px;
      border-radius: 5px;
      font-weight: normal;
    }
    
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 10px;
      border-radius: 5px;
      background-color: #e2e8f0;
      outline: none;
      transition: background 0.2s;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: var(--primary-color);
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transition: background 0.2s;
    }
    
    input[type="range"]::-webkit-slider-thumb:active {
      background: var(--primary-dark);
      transform: scale(1.1);
    }
    
    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 15px;
      margin-bottom: 5px;
    }
    
    button {
      -webkit-appearance: none;
      appearance: none;
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 12px 20px;
      font-size: 16px;
      font-weight: 500;
      border-radius: var(--border-radius);
      cursor: pointer;
      flex: 1 0 auto;
      min-width: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    
    button:active {
      background-color: var(--primary-dark);
      transform: translateY(1px);
    }
    
    .btn-secondary {
      background-color: var(--secondary-color);
    }
    
    .btn-secondary:active {
      background-color: var(--secondary-dark);
    }
    
    .btn-danger {
      background-color: var(--danger-color);
    }
    
    .btn-danger:active {
      background-color: var(--danger-dark);
    }
    
    .btn-outline {
      background-color: transparent;
      color: var(--primary-color);
      border: 2px solid var(--primary-color);
    }
    
    .btn-outline:active {
      background-color: rgba(59, 130, 246, 0.1);
    }
    
    .btn-icon {
      width: 44px;
      min-width: auto;
      padding: 10px;
    }
    
    .plot-container {
      width: 100%;
      height: 300px;
      margin-top: 20px;
      margin-bottom: 10px;
    }
    
    .calibration-form {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    
    .calibration-input {
      flex: 1;
      min-width: 180px;
      display: flex;
      align-items: center;
    }
    
    input[type="number"] {
      display: block;
      width: 100%;
      padding: 12px;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      font-size: 16px;
      background-color: white;
    }
    
    input[type="number"]:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 15px;
    }
    
    table th,
    table td {
      padding: 12px 10px;
      text-align: center;
      border: 1px solid var(--border-color);
    }
    
    table th {
      background-color: #f1f5f9;
      font-weight: 600;
    }
    
    table tr:nth-child(even) {
      background-color: #f8fafc;
    }
    
    .cal-result {
      padding: 10px;
      background-color: #f1f5f9;
      border-radius: var(--border-radius);
      font-weight: 500;
      text-align: center;
      margin-bottom: 15px;
    }
    
    /* iPadÁâπÂÆöÊ®£Âºè */
    @media only screen and (min-width: 768px) {
      .container {
        padding: 20px;
        max-width: 1000px;
      }
      
      .two-column {
        display: flex;
        gap: 20px;
      }
      
      .column {
        flex: 1;
      }
      
      .plot-container {
        height: 400px;
      }
      
      button {
        padding: 12px 24px;
      }
    }
    
    /* iPadÊ©´ÂêëÊ®°Âºè */
    @media only screen and (min-width: 1024px) {
      .container {
        padding: 30px;
      }
      
      .canvas-container {
        max-height: 500px;
      }
    }
    
    /* Ê∑±Ëâ≤Ê®°ÂºèÊîØÊè¥ */
    @media (prefers-color-scheme: dark) {
      :root {
        --background-color: #0f172a;
        --text-color: #f8fafc;
        --border-color: #334155;
      }
      
      .section {
        background-color: #1e293b;
      }
      
      input[type="range"] {
        background-color: #334155;
      }
      
      input[type="number"] {
        background-color: #1e293b;
        color: var(--text-color);
      }
      
      table th {
        background-color: #334155;
      }
      
      table tr:nth-child(even) {
        background-color: #1e293b;
      }
      
      .cal-result {
        background-color: #334155;
      }
      
      .slider-value {
        background-color: #1e293b;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>üì± iPadÂÖâË≠úÂàÜÊûêÂ∑•ÂÖ∑</h1>
    </div>
    
    <div class="section">
      <h2 class="section-title">ÂúñÂÉèËº∏ÂÖ•</h2>
      
      <div class="file-input-wrapper">
        <div class="file-buttons">
          <button id="selectPhotoBtn" class="btn-secondary">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M4 16L8.586 11.414C8.96106 11.0391 9.46967 10.8284 10 10.8284C10.5303 10.8284 11.0389 11.0391 11.414 11.414L16 16M14 14L15.586 12.414C15.9611 12.0391 16.4697 11.8284 17 11.8284C17.5303 11.8284 18.0389 12.0391 18.414 12.414L20 14M14 8H14.01M6 20H18C19.1046 20 20 19.1046 20 18V6C20 4.89543 19.1046 4 18 4H6C4.89543 4 4 4.89543 4 6V18C4 19.1046 4.89543 20 6 20Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            ÈÅ∏ÊìáÁõ∏Áâá
          </button>
          <button id="takePictureBtn" class="btn-secondary">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M3 9C3 7.89543 3.89543 7 5 7H5.92963C6.59834 7 7.2228 6.6658 7.59373 6.1094L8.40627 4.8906C8.7772 4.3342 9.40166 4 10.0704 4H13.9296C14.5983 4 15.2228 4.3342 15.5937 4.8906L16.4063 6.1094C16.7772 6.6658 17.4017 7 18.0704 7H19C20.1046 7 21 7.89543 21 9V18C21 19.1046 20.1046 20 19 20H5C3.89543 20 3 19.1046 3 18V9Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            ÊãçÊîùÁÖßÁâá
          </button>
        </div>
        <input type="file" id="imgInput" accept="image/*" style="display:none;" />
      </div>
      
      <div class="canvas-container">
        <canvas id="preview" touch-action="none"></canvas>
      </div>
    </div>
    
    <div class="section">
      <h2 class="section-title">ÈÅ∏ÊìáÂçÄÂüü</h2>
      
      <div class="slider-container">
        <div class="slider-label">
          X Ëµ∑Èªû <span class="slider-value" id="xStartVal">00000</span>
        </div>
        <input type="range" id="xStart" min="0" max="100" value="0" />
      </div>
      
      <div class="slider-container">
        <div class="slider-label">
          X ÁµÇÈªû <span class="slider-value" id="xEndVal">00100</span>
        </div>
        <input type="range" id="xEnd" min="0" max="100" value="100" />
      </div>
      
      <div class="button-row">
        <button id="analyzeBtn" class="btn-primary">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9 17L15 11L9 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          ÂàÜÊûêÂÖâË≠ú
        </button>
      </div>
      
      <div id="plot" class="plot-container"></div>
    </div>
    
    <div class="section">
      <h2 class="section-title">Ê≥¢Èï∑Ê†°Ê≠£</h2>
      
      <div class="slider-container">
        <div class="slider-label">
          üéØ Ê†°Ê≠£Áï´Á¥† <span class="slider-value" id="xCalibrateVal">00050</span>
        </div>
        <input type="range" id="xCalibrate" min="0" max="100" value="50" />
      </div>
      
      <div class="calibration-form">
        <div class="calibration-input">
          <label for="wavelengthInput">Â∞çÊáâÊ≥¢Èï∑ (nm)</label>
          <input type="number" id="wavelengthInput" inputmode="decimal" />
        </div>
        
        <button id="addPointBtn" class="btn-primary">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 4V20M4 12H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          Âä†ÂÖ•Ê†°Ê≠£Èªû
        </button>
      </div>
      
      <table id="calibrationTable">
        <thead>
          <tr>
            <th>#</th>
            <th>Áï´Á¥†‰ΩçÁΩÆ</th>
            <th>Ê≥¢Èï∑ (nm)</th>
            <th>Êìç‰Ωú</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      
      <div class="button-row">
        <button id="generateRegressionBtn" class="btn-secondary">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M7 15L12 10L17 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M3 10L12 3L21 10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M3 21H21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          Áî¢ÁîüÊ†°Ê≠£ÂõûÊ≠∏Á∑ö
        </button>
      </div>
      
      <div class="cal-result" id="regressionResult">Â∞öÊú™Ê†°Ê≠£</div>
    </div>
    
    <div class="section">
      <h2 class="section-title">Ê≥¢Èï∑Âº∑Â∫¶Âúñ</h2>
      
      <div class="button-row">
        <button id="plotWavelengthBtn" class="btn-primary">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M21 21H3V3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M20 7L14 13L10 9L4 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          È°ØÁ§∫Âº∑Â∫¶ÔºçÊ≥¢Èï∑Âúñ
        </button>
        <button id="toggleBackgroundBtn" class="btn-outline">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M4 16L8.586 11.414C8.96106 11.0391 9.46967 10.8284 10 10.8284C10.5303 10.8284 11.0389 11.0391 11.414 11.414L16 16M14 14L15.586 12.414C15.9611 12.0391 16.4697 11.8284 17 11.8284C17.5303 11.8284 18.0389 12.0391 18.414 12.414L20 14M14 8H14.01M6 20H18C19.1046 20 20 19.1046 20 18V6C20 4.89543 19.1046 4 18 4H6C4.89543 4 4 4.89543 4 6V18C4 19.1046 4.89543 20 6 20Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          Âä†ÂÖ•ËÉåÊôØÂúñ
        </button>
      </div>
      
      <div id="wavelengthPlot" class="plot-container"></div>
    </div>
  </div>

  <script>
    // DOMÂÖÉÁ¥†
    const canvas = document.getElementById("preview");
    const ctx = canvas.getContext("2d", { alpha: false });
    const imgInput = document.getElementById("imgInput");
    const selectPhotoBtn = document.getElementById("selectPhotoBtn");
    const takePictureBtn = document.getElementById("takePictureBtn");
    const xStartSlider = document.getElementById("xStart");
    const xEndSlider = document.getElementById("xEnd");
    const xCalibrateSlider = document.getElementById("xCalibrate");
    const xStartVal = document.getElementById("xStartVal");
    const xEndVal = document.getElementById("xEndVal");
    const xCalibrateVal = document.getElementById("xCalibrateVal");
    const wavelengthInput = document.getElementById("wavelengthInput");
    const analyzeBtn = document.getElementById("analyzeBtn");
    const addPointBtn = document.getElementById("addPointBtn");
    const generateRegressionBtn = document.getElementById("generateRegressionBtn");
    const plotWavelengthBtn = document.getElementById("plotWavelengthBtn");
    const toggleBackgroundBtn = document.getElementById("toggleBackgroundBtn");
    const regressionResult = document.getElementById("regressionResult");
    
    // ÂÖ®Â±ÄËÆäÈáè
    const img = new Image();
    let calibrationPoints = [];
    let calibration = null;
    let regressionConfirmed = false;
    let imageData, rawData, width, height;
    let backgroundImageOn = false;
    let isGestureDetected = false;
    let lastTouchDistance = 0;
    let touchStartX = 0;
    let canvasDimensions = { offsetX: 0, offsetY: 0, drawWidth: 0, drawHeight: 0 };
    
    // Ë®≠ÁΩÆÁï´Â∏É‰ª•ÈÅ©ÊáâË®≠ÂÇôÈ°ØÁ§∫
    function setupCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const container = canvas.parentElement;
      const containerWidth = container.clientWidth;
      
      // Ë®≠ÁΩÆÁï´Â∏ÉÁöÑÂØ¶ÈöõÂ∞∫ÂØ∏
      canvas.width = containerWidth * dpr;
      canvas.height = (containerWidth * 0.75) * dpr; // ‰øùÊåÅ4:3Êàñ16:9ÁöÑÊØî‰æã
      
      // ‰øùÊåÅÈ°ØÁ§∫Â∞∫ÂØ∏‰∏çËÆä
      canvas.style.width = `${containerWidth}px`;
      canvas.style.height = `${containerWidth * 0.75}px`;
      
      // Ë™øÊï¥Áπ™Âúñ‰∏ä‰∏ãÊñáÊØî‰æã
      ctx.scale(dpr, dpr);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
    }
    
    // ‰øùÊåÅÂúñÁâáÊØî‰æãÁπ™Ë£Ω
    function drawImageMaintainAspect(img, ctx, canvas) {
      const dpr = window.devicePixelRatio || 1;
      const canvasWidth = canvas.width / dpr;
      const canvasHeight = canvas.height / dpr;
      const imgRatio = img.naturalWidth / img.naturalHeight;
      const canvasRatio = canvasWidth / canvasHeight;
      
      let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
      
      if (imgRatio > canvasRatio) {
        // ÂúñÁâáÊØîÁï´Â∏ÉÊõ¥ÂØ¨
        drawWidth = canvasWidth;
        drawHeight = canvasWidth / imgRatio;
        offsetY = (canvasHeight - drawHeight) / 2;
      } else {
        // ÂúñÁâáÊØîÁï´Â∏ÉÊõ¥È´òÊàñÁ≠âÊØî‰æã
        drawHeight = canvasHeight;
        drawWidth = canvasHeight * imgRatio;
        offsetX = (canvasWidth - drawWidth) / 2;
      }
      
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
      
      canvasDimensions = { offsetX, offsetY, drawWidth, drawHeight };
      return canvasDimensions;
    }
    
    // ‰∫î‰ΩçÊï∏Ê†ºÂºèÂåñ
    function formatNumber(n) {
      return n.toString().padStart(5, "0");
    }
    
    // Êõ¥Êñ∞ÊªëÊ°ø
    function updateSliders(max) {
      [xStartSlider, xEndSlider, xCalibrateSlider].forEach(slider => {
        slider.max = max;
      });
      xStartSlider.value = 0;
      xEndSlider.value = max;
      xCalibrateSlider.value = Math.floor(max / 2);
      syncSliderValues();
    }
    
    // ÂêåÊ≠•ÊªëÊ°øÂÄº
    function syncSliderValues() {
      let x1 = parseInt(xStartSlider.value);
      let x2 = parseInt(xEndSlider.value);
      if (x2 < x1) [x1, x2] = [x2, x1];
      
      xStartVal.textContent = formatNumber(x1);
      xEndVal.textContent = formatNumber(x2);
      xCalibrateVal.textContent = formatNumber(xCalibrateSlider.value);
      
      xCalibrateSlider.min = x1;
      xCalibrateSlider.max = x2;
      
      // ‰ΩøÁî®requestAnimationFrame‰æÜÁ¢∫‰øùÁï´Èù¢Êõ¥Êñ∞
      requestAnimationFrame(drawWithRectangle);
    }
    
    // Áπ™Ë£ΩÊñπÊ°Ü
    function drawWithRectangle() {
      if (!img.complete || img.naturalWidth === 0) return;
      
      const dpr = window.devicePixelRatio || 1;
      const canvasWidth = canvas.width / dpr;
      const canvasHeight = canvas.height / dpr;
      
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      const { offsetX, offsetY, drawWidth, drawHeight } = drawImageMaintainAspect(img, ctx, canvas);
      
      let x1 = parseInt(xStartSlider.value);
      let x2 = parseInt(xEndSlider.value);
      if (x2 < x1) [x1, x2] = [x2, x1];
      
      // Ë®àÁÆóÁ∏ÆÊîæÊØî‰æã
      let xScale = drawWidth / width;
      let yScale = drawHeight / height;
      
      // ‰ΩøÁî®Êï¥Êï∏‰ΩçÁΩÆ+0.5‰æÜÁπ™Ë£ΩÊõ¥Ê∏ÖÊô∞ÁöÑÁ∑öÊ¢ù
      let rectX1 = Math.floor(offsetX + x1 * xScale) + 0.5;
      let rectX2 = Math.floor(offsetX + x2 * xScale) + 0.5;
      let rectY1 = Math.floor(offsetY + height * 0.45 * yScale) + 0.5;
      let rectY2 = Math.floor(offsetY + height * 0.55 * yScale) + 0.5;
      
      ctx.strokeStyle = "yellow";
      ctx.lineWidth = 2;
      
      // ‰ΩøÁî®Ë∑ØÂæë‰æÜÁπ™Ë£ΩÊõ¥Á≤æÁ¢∫ÁöÑÁü©ÂΩ¢
      ctx.beginPath();
      ctx.moveTo(rectX1, rectY1);
      ctx.lineTo(rectX2, rectY1);
      ctx.lineTo(rectX2, rectY2);
      ctx.lineTo(rectX1, rectY2);
      ctx.closePath();
      ctx.stroke();
    }
    
    // ÊèêÂèñÂíåÁπ™Ë£ΩÂº∑Â∫¶Âúñ
    function extractAndPlot() {
      if (!rawData) {
        showNotification("Ë´ãÂÖà‰∏äÂÇ≥ÂúñÁâáÔºÅ");
        return;
      }
      
      let x1 = parseInt(xStartSlider.value);
      let x2 = parseInt(xEndSlider.value);
      if (x2 < x1) [x1, x2] = [x2, x1];
      let y1 = Math.floor(height * 0.45) + 2;
      let y2 = Math.floor(height * 0.55) - 2;
      
      let dataX = [], dataY = [];
      
      for (let x = x1; x <= x2; x++) {
        let sum = 0;
        for (let y = y1; y <= y2; y++) {
          let idx = (y * width + x) * 4;
          if (idx < rawData.length) {
            let r = rawData[idx];
            let g = rawData[idx + 1];
            let b = rawData[idx + 2];
            let intensity = (r + g + b) / 3;
            sum += intensity;
          }
        }
        let avg = sum / (y2 - y1 + 1);
        dataX.push(x);
        dataY.push(avg);
      }
      
      let shapes = [{
        type: "line",
        x0: parseInt(xCalibrateSlider.value),
        x1: parseInt(xCalibrateSlider.value),
        y0: 0,
        y1: Math.max(...dataY),
        line: { color: "red", width: 2, dash: "dot" }
      }];
      
      // ‰ΩøÁî®PlotlyÁπ™Ë£ΩÈÅ©ÂêàËß∏ÊéßÊìç‰ΩúÁöÑÂúñË°®
      Plotly.newPlot("plot", [{
        x: dataX,
        y: dataY,
        mode: "lines",
        name: "ÂÉèÁ¥†Âº∑Â∫¶",
        line: { color: "#3b82f6", width: 3 }
      }], {
        margin: { t: 20, r: 20, b: 40, l: 50 },
        xaxis: { 
          title: "ÂÉèÁ¥†‰ΩçÁΩÆ",
          showline: true,
          mirror: true,
          ticks: 'outside',
          linecolor: 'black',
          linewidth: 2,
          tickfont: { size: 14 }
        },
        yaxis: { 
          title: "Âº∑Â∫¶",
          showline: true,
          mirror: true,
          ticks: 'outside',
          linecolor: 'black',
          linewidth: 2,
          tickfont: { size: 14 }
        },
        shapes: shapes,
        dragmode: 'pan',
        modeBarButtonsToAdd: [
          'hoverClosestCartesian',
          'hoverCompareCartesian',
          'toggleSpikelines'
        ],
        hovermode: 'closest',
        colorway: ['#3b82f6', '#ef4444', '#22c55e'],
        plot_bgcolor: 'rgba(255,255,255,0)',
        paper_bgcolor: 'rgba(255,255,255,0)'
      }, { 
        displayModeBar: true, 
        responsive: true,
        toImageButtonOptions: {
          format: 'png',
          filename: 'spectrum_intensity',
          scale: 2
        },
        modeBarButtonsToRemove: [
          'lasso2d', 
          'select2d',
          'autoScale2d'
        ]
      });
    }
    
    // Êõ¥Êñ∞Ê†°Ê≠£Ë°®Ê†º
    function updateCalibrationTable() {
      const tbody = document.querySelector("#calibrationTable tbody");
      tbody.innerHTML = "";
      
      calibrationPoints.forEach((p, index) => {
        const row = document.createElement("tr");
        
        const cellIndex = document.createElement("td");
        const cellPixel = document.createElement("td");
        const cellWavelength = document.createElement("td");
        const cellDelete = document.createElement("td");
        
        cellIndex.textContent = index + 1;
        cellPixel.textContent = p.pixel;
        cellWavelength.textContent = p.wavelength.toFixed(2);
        
        const deleteBtn = document.createElement("button");
        deleteBtn.textContent = "‚ùå";
        deleteBtn.classList.add("btn-danger", "btn-icon");
        deleteBtn.onclick = (e) => {
          e.preventDefault();
          calibrationPoints.splice(index, 1);
          regressionConfirmed = false;
          calibration = null;
          regressionResult.textContent = "Â∞öÊú™Ê†°Ê≠£";
          updateCalibrationTable();
        };
        
        cellDelete.appendChild(deleteBtn);
        
        row.appendChild(cellIndex);
        row.appendChild(cellPixel);
        row.appendChild(cellWavelength);
        row.appendChild(cellDelete);
        tbody.appendChild(row);
      });
    }
    
    // Áç≤ÂèñÈÅ∏ÂÆöÁØÑÂúçÁöÑÂúñÂÉèÊï∏ÊìöURL
    function getSelectedImageDataURL(x1, x2, y1, y2) {
      const cropCanvas = document.createElement("canvas");
      const cropCtx = cropCanvas.getContext("2d");
      const cropWidth = x2 - x1 + 1;
      const cropHeight = y2 - y1 + 1;
      
      cropCanvas.width = cropWidth;
      cropCanvas.height = cropHeight;
      
      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = width;
      tempCanvas.height = height;
      const tempCtx = tempCanvas.getContext("2d");
      tempCtx.putImageData(imageData, 0, 0);
      
      try {
        const cropImageData = tempCtx.getImageData(x1, y1, cropWidth, cropHeight);
        cropCtx.putImageData(cropImageData, 0, 0);
        return cropCanvas.toDataURL();
      } catch (e) {
        console.error("Ë£ÅÂâ™ÂúñÂÉèÁôºÁîüÈåØË™§:", e);
        return null;
      }
    }
    
    // Áπ™Ë£ΩÊ≥¢Èï∑Âº∑Â∫¶Âúñ
    function plotWavelengthGraph() {
      if (!rawData) {
        showNotification("Ë´ãÂÖà‰∏äÂÇ≥ÂúñÁâáÔºÅ");
        return;
      }
      
      if (!calibration) {
        showNotification("Ë´ãÂÖàÂä†ÂÖ•Ëá≥Â∞ëÂÖ©ÂÄãÊ†°Ê≠£ÈªûÔºå‰∏¶ÂÆåÊàêÊ†°Ê≠£ÔºÅ");
        return;
      }
      
      let x1 = parseInt(xStartSlider.value);
      let x2 = parseInt(xEndSlider.value);
      if (x2 < x1) [x1, x2] = [x2, x1];
      let y1 = Math.floor(height * 0.45) + 2;
      let y2 = Math.floor(height * 0.55) - 2;
      
      let dataX = [], dataY = [];
      
      for (let x = x1; x <= x2; x++) {
        let sum = 0;
        for (let y = y1; y <= y2; y++) {
          let idx = (y * width + x) * 4;
          if (idx < rawData.length) {
            let r = rawData[idx];
            let g = rawData[idx + 1];
            let b = rawData[idx + 2];
            let intensity = (r + g + b) / 3;
            sum += intensity;
          }
        }
        let avg = sum / (y2 - y1 + 1);
        dataX.push(x);
        dataY.push(avg);
      }
      
      const { a, b } = calibration;
      let wavelengthX = dataX.map(x => a * x + b);
      
      Plotly.newPlot("wavelengthPlot", [{
        x: wavelengthX,
        y: dataY,
        mode: "lines",
        name: "Ê≥¢Èï∑Âº∑Â∫¶",
        line: { color: "#22c55e", width: 3 }
      }], {
        margin: { t: 20, r: 20, b: 40, l: 50 },
        xaxis: {
          title: "Ê≥¢Èï∑ (nm)",
          showline: true,
          mirror: true,
          ticks: 'outside',
          linecolor: 'black',
          linewidth: 2,
          tickfont: { size: 14 }
        },
        yaxis: {
          title: "Âº∑Â∫¶",
          showline: true,
          mirror: true,
          ticks: 'outside',
          linecolor: 'black',
          linewidth: 2,
          tickfont: { size: 14 }
        },
        dragmode: 'pan',
        modeBarButtonsToAdd: [
          'hoverClosestCartesian',
          'hoverCompareCartesian',
          'toggleSpikelines'
        ],
        hovermode: 'closest',
        images: [],
        plot_bgcolor: 'rgba(255,255,255,0)',
        paper_bgcolor: 'rgba(255,255,255,0)'
      }, { 
        displayModeBar: true, 
        responsive: true,
        toImageButtonOptions: {
          format: 'png',
          filename: 'spectrum_wavelength',
          scale: 2
        },
        modeBarButtonsToRemove: [
          'lasso2d', 
          'select2d',
          'autoScale2d'
        ]
      });
      
      // ÈáçÁΩÆËÉåÊôØÂúñÁãÄÊÖã
      backgroundImageOn = false;
      toggleBackgroundBtn.textContent = "üñº Âä†ÂÖ•ËÉåÊôØÂúñ";
      toggleBackgroundBtn.classList.add("btn-outline");
      toggleBackgroundBtn.classList.remove("btn-danger");
    }
    
    // ÂàáÊèõËÉåÊôØÂúñ
    function toggleBackground() {
      if (!rawData || !calibration) {
        showNotification("Ë´ãÂÖàÂä†ÂÖ•Ëá≥Â∞ëÂÖ©ÂÄãÊ†°Ê≠£ÈªûÔºå‰∏¶ÂÆåÊàêÊ†°Ê≠£ÔºÅ");
        return;
      }
      
      let x1 = parseInt(xStartSlider.value);
      let x2 = parseInt(xEndSlider.value);
      if (x2 < x1) [x1, x2] = [x2, x1];
      let y1 = Math.floor(height * 0.45) + 2;
      let y2 = Math.floor(height * 0.55) - 2;
      
      const { a, b } = calibration;
      const wlStart = a * x1 + b;
      const wlEnd = a * x2 + b;
      
      if (!backgroundImageOn) {
        // Âä†ÂÖ•ËÉåÊôØÂúñ
        const imageDataUrl = getSelectedImageDataURL(x1, x2, y1, y2);
        
        if (imageDataUrl) {
          const bgImage = {
            source: imageDataUrl,
            xref: "x",
            yref: "paper",
            x: wlStart,
            y: 1,
            sizex: wlEnd - wlStart,
            sizey: 1,
            sizing: "stretch",
            opacity: 0.6,
            layer: "below"
          };
          
          Plotly.relayout("wavelengthPlot", {
            images: [bgImage]
          });
          
          backgroundImageOn = true;
          toggleBackgroundBtn.textContent = "üö´ ÁßªÈô§ËÉåÊôØÂúñ";
          toggleBackgroundBtn.classList.remove("btn-outline");
          toggleBackgroundBtn.classList.add("btn-danger");
        } else {
          showNotification("ÁÑ°Ê≥ïÁîüÊàêËÉåÊôØÂúñÁâáÔºåË´ãÊ™¢Êü•ÈÅ∏ÊìáÁØÑÂúçÔºÅ");
        }
      } else {
        // ÁßªÈô§ËÉåÊôØÂúñ
        Plotly.relayout("wavelengthPlot", {
          images: []
        });
        
        backgroundImageOn = false;
        toggleBackgroundBtn.textContent = "üñº Âä†ÂÖ•ËÉåÊôØÂúñ";
        toggleBackgroundBtn.classList.add("btn-outline");
        toggleBackgroundBtn.classList.remove("btn-danger");
      }
    }
    
    // ÂúñÁâáÂä†ËºâËôïÁêÜ
    function loadImageFromFile(file) {
      if (!file) return;
      
      const reader = new FileReader();
      
      reader.onload = function(e) {
        img.onload = function() {
          width = img.naturalWidth;
          height = img.naturalHeight;
          
          setupCanvas();
          
          updateSliders(width - 1);
          
          // ‰ΩøÁî®PromiseÁ¢∫‰øùÂúñÁâáÂÆåÂÖ®Ëß£Á¢ºÂæåÂÜçËôïÁêÜ
          if (img.decode) {
            img.decode().then(() => {
              processLoadedImage();
            }).catch(err => {
              console.error("ÂúñÁâáËß£Á¢ºÂ§±Êïó:", err);
              processLoadedImage();
            });
          } else {
            processLoadedImage();
          }
        };
        
        img.src = e.target.result;
      };
      
      reader.readAsDataURL(file);
    }
    
    // ËôïÁêÜÂä†ËºâÂ•ΩÁöÑÂúñÁâá
    function processLoadedImage() {
      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = width;
      tempCanvas.height = height;
      const tempCtx = tempCanvas.getContext("2d");
      tempCtx.drawImage(img, 0, 0);
      
      try {
        imageData = tempCtx.getImageData(0, 0, width, height);
        rawData = imageData.data;
        
        drawWithRectangle();
        showNotification("ÂúñÁâáÂ∑≤ÊàêÂäüËºâÂÖ•", "success");
      } catch (e) {
        console.error("ËôïÁêÜÂúñÁâáÊôÇÁôºÁîüÈåØË™§:", e);
        showNotification("ÂúñÁâáËôïÁêÜÂ§±ÊïóÔºåË´ãÂòóË©¶‰ΩøÁî®ÂÖ∂‰ªñÂúñÁâá„ÄÇ", "error");
      }
    }
    
    // Ê∑ªÂä†Ê†°Ê≠£Èªû
    function addCalibrationPoint() {
      const pixel = parseInt(xCalibrateSlider.value);
      const wavelength = parseFloat(wavelengthInput.value);
      
      if (isNaN(pixel) || isNaN(wavelength)) {
        showNotification("Ë´ãËº∏ÂÖ•ÊúâÊïàÁöÑÁï´Á¥†ËàáÊ≥¢Èï∑ÔºÅ", "error");
        return;
      }
      
      calibrationPoints.push({ pixel, wavelength });
      regressionConfirmed = false;
      calibration = null;
      regressionResult.textContent = "Â∞öÊú™Ê†°Ê≠£";
      updateCalibrationTable();
      showNotification("Â∑≤Âä†ÂÖ•Ê†°Ê≠£Èªû", "success");
      wavelengthInput.value = "";
    }
    
    // ÁîüÊàêÂõûÊ≠∏Á∑ö
    function generateRegression() {
      if (calibrationPoints.length < 2) {
        showNotification("Ë´ãËá≥Â∞ëËº∏ÂÖ•ÂÖ©ÂÄãÊ†°Ê≠£ÈªûÔºÅ", "error");
        return;
      }
      
      // ‰ΩøÁî®ÊâÄÊúâÊ†°Ê≠£ÈªûÈÄ≤Ë°åÁ∑öÊÄßÂõûÊ≠∏
      let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
      const n = calibrationPoints.length;
      
      calibrationPoints.forEach(p => {
        sumX += p.pixel;
        sumY += p.wavelength;
        sumXY += p.pixel * p.wavelength;
        sumX2 += p.pixel * p.pixel;
      });
      
      const a = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      const b = (sumY - a * sumX) / n;
      
      calibration = { a, b };
      regressionConfirmed = true;
      
      regressionResult.textContent = `Œª = ${a.toFixed(4)} √ó x + ${b.toFixed(2)}`;
      showNotification("Â∑≤ÁîüÊàêÊ†°Ê≠£ÊñπÁ®ãÂºè", "success");
    }
    
    // È°ØÁ§∫ÈÄöÁü•ÊèêÁ§∫
    function showNotification(message, type = "info") {
      // ÂâµÂª∫ÈÄöÁü•ÂÖÉÁ¥†
      const notification = document.createElement("div");
      notification.textContent = message;
      notification.style.position = "fixed";
      notification.style.bottom = "20px";
      notification.style.left = "50%";
      notification.style.transform = "translateX(-50%)";
      notification.style.padding = "12px 20px";
      notification.style.borderRadius = "8px";
      notification.style.fontWeight = "500";
      notification.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.15)";
      notification.style.zIndex = "9999";
      notification.style.maxWidth = "80%";
      notification.style.textAlign = "center";
      
      // Ë®≠ÁΩÆ‰∏çÂêåÈ°ûÂûãÁöÑÊ®£Âºè
      switch(type) {
        case "success":
          notification.style.backgroundColor = "#22c55e";
          notification.style.color = "white";
          break;
        case "error":
          notification.style.backgroundColor = "#ef4444";
          notification.style.color = "white";
          break;
        default:
          notification.style.backgroundColor = "#3b82f6";
          notification.style.color = "white";
      }
      
      // Ê∑ªÂä†Âà∞È†ÅÈù¢‰∏¶Âú®2ÁßíÂæåÁßªÈô§
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.opacity = "0";
        notification.style.transition = "opacity 0.5s ease";
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 500);
      }, 2000);
    }
    
    // Â§öÈªûËß∏ÊéßÊâãÂã¢ËôïÁêÜ
    function setupGestureEvents() {
      // Ëß∏ÊéßÈñãÂßã
      canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
          // ÂÖ©ÊåáËß∏ÊéßÔºåÊ∫ñÂÇôÈÄ≤Ë°åÁ∏ÆÊîæÊàñÊªëÂãï
          isGestureDetected = true;
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          lastTouchDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );
          touchStartX = (touch1.clientX + touch2.clientX) / 2;
        } else if (e.touches.length === 1) {
          // ÂñÆÊåáËß∏ÊéßÔºåÊ∫ñÂÇôÁßªÂãïÊ†°Ê≠£Èªû
          touchStartX = e.touches[0].clientX;
        }
        e.preventDefault();
      }, { passive: false });
      
      // Ëß∏ÊéßÁßªÂãï
      canvas.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2 && isGestureDetected) {
          // ÂÖ©ÊåáÊâãÂã¢ËôïÁêÜ
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const touchDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );
          
          // Ë®àÁÆóÁ∏ÆÊîæÊØî‰æã
          const scale = touchDistance / lastTouchDistance;
          lastTouchDistance = touchDistance;
          
          // Ë®àÁÆó‰∏≠ÂøÉÈªû
          const touchCenterX = (touch1.clientX + touch2.clientX) / 2;
          const touchDeltaX = touchCenterX - touchStartX;
          touchStartX = touchCenterX;
          
          // ÊáâÁî®Á∏ÆÊîæÊàñÂπ≥ÁßªÂà∞ÊªëÊ°øÊéß‰ª∂
          if (Math.abs(scale - 1) > 0.05) {
            // Á∏ÆÊîæÊìç‰Ωú - Ë™øÊï¥ÈñãÂßãÂíåÁµêÊùüÈªûÁöÑË∑ùÈõ¢
            const x1 = parseInt(xStartSlider.value);
            const x2 = parseInt(xEndSlider.value);
            const range = x2 - x1;
            const midPoint = (x1 + x2) / 2;
            
            const newRange = Math.max(10, Math.min(width - 1, range * scale));
            const newX1 = Math.max(0, Math.round(midPoint - newRange / 2));
            const newX2 = Math.min(width - 1, Math.round(midPoint + newRange / 2));
            
            xStartSlider.value = newX1;
            xEndSlider.value = newX2;
            syncSliderValues();
          } else if (Math.abs(touchDeltaX) > 5) {
            // Âπ≥ÁßªÊìç‰Ωú - ‰øùÊåÅÁØÑÂúç‰∏çËÆä‰ΩÜÁßªÂãï‰ΩçÁΩÆ
            const x1 = parseInt(xStartSlider.value);
            const x2 = parseInt(xEndSlider.value);
            const range = x2 - x1;
            
            // Â∞áËß∏ÊéßÁßªÂãïËΩâÊèõÁÇ∫ÂÉèÁ¥†ÁßªÂãï
            const pixelDelta = Math.round(touchDeltaX * width / canvas.clientWidth);
            
            if (Math.abs(pixelDelta) > 0) {
              let newX1 = x1 + pixelDelta;
              let newX2 = x2 + pixelDelta;
              
              // ‰øùË≠â‰∏çË∂ÖÂá∫ÈÇäÁïå
              if (newX1 < 0) {
                newX1 = 0;
                newX2 = range;
              }
              
              if (newX2 > width - 1) {
                newX2 = width - 1;
                newX1 = newX2 - range;
              }
              
              xStartSlider.value = newX1;
              xEndSlider.value = newX2;
              syncSliderValues();
            }
          }
        } else if (e.touches.length === 1 && !isGestureDetected) {
          // ÂñÆÊåáÁßªÂãï - ÁßªÂãïÊ†°Ê≠£Èªû
          const touch = e.touches[0];
          const touchDeltaX = touch.clientX - touchStartX;
          touchStartX = touch.clientX;
          
          // Â∞áËß∏ÊéßÁßªÂãïËΩâÊèõÁÇ∫ÂÉèÁ¥†ÁßªÂãï
          const pixelDelta = Math.round(touchDeltaX * width / canvas.clientWidth);
          
          if (Math.abs(pixelDelta) > 0) {
            const newPosition = parseInt(xCalibrateSlider.value) + pixelDelta;
            xCalibrateSlider.value = Math.max(xCalibrateSlider.min, Math.min(xCalibrateSlider.max, newPosition));
            syncSliderValues();
            if (rawData) extractAndPlot();
          }
        }
        e.preventDefault();
      }, { passive: false });
      
      // Ëß∏ÊéßÁµêÊùü
      canvas.addEventListener('touchend', (e) => {
        isGestureDetected = false;
        
        // Â¶ÇÊûú‰πãÂâçÊòØÂú®ÊãñÊîæÊ†°Ê≠£Èªû‰∏¶‰∏îÈÇÑÊúâÊøÄÊ¥ªÁöÑËß∏ÊéßÔºåÊõ¥Êñ∞ÂúñË°®
        if (e.touches.length === 0 && rawData) {
          extractAndPlot();
        }
      });
      
      // ÈòªÊ≠¢Á∏ÆÊîæ
      canvas.addEventListener('gesturestart', (e) => {
        e.preventDefault();
      }, { passive: false });
    }
    
    // Áõ∏Ê©üÊï¥Âêà - ÊãçÊîùÂúñÁâá
    function setupCameraIntegration() {
      // Ê™¢Êü•ÊòØÂê¶ÊîØÊè¥getUserMedia
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        takePictureBtn.addEventListener('click', () => {
          // ÂâµÂª∫Áõ∏Ê©üÂÖÉÁ¥†
          const videoElement = document.createElement('video');
          videoElement.setAttribute('autoplay', '');
          videoElement.setAttribute('playsinline', '');
          videoElement.style.display = 'none';
          document.body.appendChild(videoElement);
          
          // ÂâµÂª∫ÊãçÁÖßÁïåÈù¢
          const cameraContainer = document.createElement('div');
          cameraContainer.style.position = 'fixed';
          cameraContainer.style.top = '0';
          cameraContainer.style.left = '0';
          cameraContainer.style.width = '100%';
          cameraContainer.style.height = '100%';
          cameraContainer.style.backgroundColor = 'black';
          cameraContainer.style.zIndex = '10000';
          cameraContainer.style.display = 'flex';
          cameraContainer.style.flexDirection = 'column';
          
          const cameraPreview = document.createElement('div');
          cameraPreview.style.flex = '1';
          cameraPreview.style.position = 'relative';
          cameraPreview.style.overflow = 'hidden';
          
          const cameraVideo = document.createElement('video');
          cameraVideo.setAttribute('autoplay', '');
          cameraVideo.setAttribute('playsinline', '');
          cameraVideo.style.width = '100%';
          cameraVideo.style.height = '100%';
          cameraVideo.style.objectFit = 'cover';
          
          const cameraControls = document.createElement('div');
          cameraControls.style.padding = '20px';
          cameraControls.style.display = 'flex';
          cameraControls.style.justifyContent = 'space-around';
          cameraControls.style.backgroundColor = 'rgba(0,0,0,0.7)';
          
          const cancelButton = document.createElement('button');
          cancelButton.textContent = 'ÂèñÊ∂à';
          cancelButton.classList.add('btn-danger');
          
          const captureButton = document.createElement('button');
          captureButton.textContent = 'ÊãçÊîù';
          captureButton.classList.add('btn-secondary');
          
          cameraControls.appendChild(cancelButton);
          cameraControls.appendChild(captureButton);
          
          cameraPreview.appendChild(cameraVideo);
          cameraContainer.appendChild(cameraPreview);
          cameraContainer.appendChild(cameraControls);
          
          document.body.appendChild(cameraContainer);
          
          // Ë´ãÊ±ÇÁõ∏Ê©üÊ¨äÈôê
          navigator.mediaDevices.getUserMedia({ 
            video: { 
              facingMode: 'environment', // ‰ΩøÁî®ÂæåÁΩÆÁõ∏Ê©ü
              width: { ideal: 1920 },
              height: { ideal: 1080 }
            } 
          })
          .then(function(stream) {
            videoElement.srcObject = stream;
            cameraVideo.srcObject = stream;
            
            // ÊãçÁÖßÊåâÈàï‰∫ã‰ª∂
            captureButton.addEventListener('click', () => {
              const tempCanvas = document.createElement('canvas');
              tempCanvas.width = cameraVideo.videoWidth;
              tempCanvas.height = cameraVideo.videoHeight;
              const tempCtx = tempCanvas.getContext('2d');
              
              // Áπ™Ë£ΩË¶ñÈ†ªÂπÄÂà∞canvas
              tempCtx.drawImage(cameraVideo, 0, 0);
              
              // Â∞ácanvasËΩâÊèõÁÇ∫Blob
              tempCanvas.toBlob((blob) => {
                // ÂâµÂª∫‰∏ÄÂÄãFileÂ∞çË±°
                const file = new File([blob], "camera-capture.jpg", { type: "image/jpeg" });
                
                // Âä†ËºâÂúñÁâá
                loadImageFromFile(file);
                
                // Ê∏ÖÁêÜ
                stream.getTracks().forEach(track => track.stop());
                document.body.removeChild(cameraContainer);
                document.body.removeChild(videoElement);
              }, 'image/jpeg', 0.95);
            });
            
            // ÂèñÊ∂àÊåâÈàï‰∫ã‰ª∂
            cancelButton.addEventListener('click', () => {
              stream.getTracks().forEach(track => track.stop());
              document.body.removeChild(cameraContainer);
              document.body.removeChild(videoElement);
            });
          })
          .catch(function(error) {
            showNotification('ÁÑ°Ê≥ïÂ≠òÂèñÁõ∏Ê©ü: ' + error.message, 'error');
            document.body.removeChild(cameraContainer);
            document.body.removeChild(videoElement);
          });
        });
      } else {
        takePictureBtn.style.display = 'none';
      }
    }
    
    // ‰∫ã‰ª∂Áõ£ËÅΩÂô®
    function setupEventListeners() {
      // Ê™îÊ°àÈÅ∏ÊìáÊåâÈàï
      selectPhotoBtn.addEventListener('click', () => {
        imgInput.click();
      });
      
      imgInput.addEventListener("change", e => loadImageFromFile(e.target.files[0]));
      
      // ÊªëÊ°ø‰∫ã‰ª∂
      xStartSlider.addEventListener("input", syncSliderValues);
      xEndSlider.addEventListener("input", syncSliderValues);
      xCalibrateSlider.addEventListener("input", () => {
        syncSliderValues();
        if (rawData) extractAndPlot();
      });
      
      // ÂàÜÊûêÂíåÊ†°Ê≠£ÊåâÈàï
      analyzeBtn.addEventListener("click", extractAndPlot);
      addPointBtn.addEventListener("click", addCalibrationPoint);
      generateRegressionBtn.addEventListener("click", generateRegression);
      plotWavelengthBtn.addEventListener("click", plotWavelengthGraph);
      toggleBackgroundBtn.addEventListener("click", toggleBackground);
      
      // Ê≥¢Èï∑Ëº∏ÂÖ•Ê°ÜÊåâEnterÁ¢∫Ë™ç
      wavelengthInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          addCalibrationPoint();
        }
      });
      
      // Áõ£ËÅΩÁ™óÂè£Â§ßÂ∞èËÆäÂåñ
      window.addEventListener('resize', () => {
        if (img.complete && img.naturalWidth > 0) {
          setupCanvas();
          requestAnimationFrame(drawWithRectangle);
        }
      });
      
      // Á¶ÅÁî®ÈõôÊåáÁ∏ÆÊîæÈ†ÅÈù¢
      document.addEventListener('gesturestart', (e) => {
        e.preventDefault();
      }, { passive: false });
      
      document.addEventListener('gesturechange', (e) => {
        e.preventDefault();
      }, { passive: false });
    }
    
    // ‰øùÂ≠òÊï∏ÊìöÂà∞Êú¨Âú∞Â≠òÂÑ≤
    function saveDataToLocalStorage() {
      if (calibrationPoints.length > 0) {
        localStorage.setItem('spectrumTool_calibrationPoints', JSON.stringify(calibrationPoints));
      }
      
      if (calibration) {
        localStorage.setItem('spectrumTool_calibration', JSON.stringify(calibration));
      }
    }
    
    // ÂæûÊú¨Âú∞Â≠òÂÑ≤Âä†ËºâÊï∏Êìö
    function loadDataFromLocalStorage() {
      const savedCalibrationPoints = localStorage.getItem('spectrumTool_calibrationPoints');
      if (savedCalibrationPoints) {
        try {
          calibrationPoints = JSON.parse(savedCalibrationPoints);
          updateCalibrationTable();
        } catch (e) {
          console.error("ÁÑ°Ê≥ïËºâÂÖ•Ê†°Ê∫ñÈªû:", e);
        }
      }
      
      const savedCalibration = localStorage.getItem('spectrumTool_calibration');
      if (savedCalibration) {
        try {
          calibration = JSON.parse(savedCalibration);
          if (calibration && calibration.a && calibration.b) {
            regressionConfirmed = true;
            regressionResult.textContent = `Œª = ${calibration.a.toFixed(4)} √ó x + ${calibration.b.toFixed(2)}`;
          }
        } catch (e) {
          console.error("ÁÑ°Ê≥ïËºâÂÖ•Ê†°Ê∫ñ:", e);
        }
      }
    }
    
    // ÂàùÂßãÂåñÊáâÁî®
    function initApp() {
      setupCanvas();
      setupEventListeners();
      setupGestureEvents();
      setupCameraIntegration();
      loadDataFromLocalStorage();
      
      // ÂÆöÊúü‰øùÂ≠òÊï∏Êìö
      setInterval(saveDataToLocalStorage, 30000); // ÊØè30ÁßíËá™Âãï‰øùÂ≠ò
      
      // Ê™¢Ê∏¨ÊòØÂê¶ÁÇ∫iPad
      const isIpad = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      
      if (isIpad) {
        // È°ØÁ§∫Ê∑ªÂä†Âà∞‰∏ªÂ±èÂπïÊèêÁ§∫
        const isStandalone = window.navigator.standalone;
        const hasShownPrompt = localStorage.getItem('hasShownHomeScreenPrompt');
        
        if (!isStandalone && !hasShownPrompt) {
          setTimeout(() => {
            showAddToHomeScreenPrompt();
            localStorage.setItem('hasShownHomeScreenPrompt', 'true');
          }, 3000);
        }
      }
    }
    
    // È°ØÁ§∫Ê∑ªÂä†Âà∞‰∏ªÂ±èÂπïÊèêÁ§∫
    function showAddToHomeScreenPrompt() {
      const promptContainer = document.createElement('div');
      promptContainer.style.position = 'fixed';
      promptContainer.style.bottom = '0';
      promptContainer.style.left = '0';
      promptContainer.style.right = '0';
      promptContainer.style.backgroundColor = '#3b82f6';
      promptContainer.style.color = 'white';
      promptContainer.style.padding = '15px';
      promptContainer.style.boxShadow = '0 -2px 10px rgba(0,0,0,0.2)';
      promptContainer.style.zIndex = '9999';
      promptContainer.style.display = 'flex';
      promptContainer.style.alignItems = 'center';
      promptContainer.style.justifyContent = 'space-between';
      
      const promptText = document.createElement('div');
      promptText.innerHTML = '<strong>Ê∑ªÂä†Âà∞‰∏ªÂ±èÂπï</strong><br>Áç≤ÂæóÊõ¥Â•ΩÁöÑ‰ΩøÁî®È´îÈ©ó';
      
      const promptActions = document.createElement('div');
      promptActions.style.display = 'flex';
      promptActions.style.gap = '10px';
      
      const dismissBtn = document.createElement('button');
      dismissBtn.textContent = 'Á®çÂæåÂÜçË™™';
      dismissBtn.classList.add('btn-outline');
      dismissBtn.style.backgroundColor = 'transparent';
      dismissBtn.style.color = 'white';
      dismissBtn.style.border = '1px solid white';
      
      const addBtn = document.createElement('button');
      addBtn.textContent = 'Â¶Ç‰ΩïÊ∑ªÂä†';
      addBtn.classList.add('btn-secondary');
      
      promptActions.appendChild(dismissBtn);
      promptActions.appendChild(addBtn);
      
      promptContainer.appendChild(promptText);
      promptContainer.appendChild(promptActions);
      
      document.body.appendChild(promptContainer);
      
      dismissBtn.addEventListener('click', () => {
        document.body.removeChild(promptContainer);
      });
      
      addBtn.addEventListener('click', () => {
        const instructionsContainer = document.createElement('div');
        instructionsContainer.style.position = 'fixed';
        instructionsContainer.style.top = '0';
        instructionsContainer.style.left = '0';
        instructionsContainer.style.right = '0';
        instructionsContainer.style.bottom = '0';
        instructionsContainer.style.backgroundColor = 'rgba(0,0,0,0.8)';
        instructionsContainer.style.zIndex = '10000';
        instructionsContainer.style.display = 'flex';
        instructionsContainer.style.flexDirection = 'column';
        instructionsContainer.style.alignItems = 'center';
        instructionsContainer.style.justifyContent = 'center';
        instructionsContainer.style.padding = '20px';
        
        const instructions = document.createElement('div');
        instructions.style.backgroundColor = 'white';
        instructions.style.borderRadius = '12px';
        instructions.style.padding = '20px';
        instructions.style.maxWidth = '400px';
        instructions.style.width = '100%';
        instructions.style.textAlign = 'center';
        
        instructions.innerHTML = `
          <h3 style="margin-top:0;">Ê∑ªÂä†Âà∞‰∏ªÂ±èÂπïÊ≠•È©ü</h3>
          <p>1. ÈªûÊìäSafariÂ∫ïÈÉ®ÁöÑ<strong>ÂàÜ‰∫´ÊåâÈàï</strong> <span style="font-size:24px;">‚¨ÜÔ∏è</span></p>
          <p>2. Âú®ÈÅ∏È†Ö‰∏≠ÊâæÂà∞‰∏¶ÈªûÊìä<strong>Ê∑ªÂä†Âà∞‰∏ªÂ±èÂπï</strong></p>
          <p>3. ÈªûÊìä<strong>Ê∑ªÂä†</strong>Á¢∫Ë™ç</p>
          <button id="closeInstructions" style="margin-top:15px;padding:10px 20px;background-color:#3b82f6;color:white;border:none;border-radius:8px;font-weight:500;">‰∫ÜËß£‰∫Ü</button>
        `;
        
        instructionsContainer.appendChild(instructions);
        document.body.appendChild(instructionsContainer);
        
        document.getElementById('closeInstructions').addEventListener('click', () => {
          document.body.removeChild(instructionsContainer);
          document.body.removeChild(promptContainer);
        });
      });
    }
    
    // Ê™¢Êü•ÂíåËôïÁêÜÈõ¢Á∑öÊ®°Âºè
    function setupOfflineSupport() {
      window.addEventListener('online', () => {
        showNotification('Â∑≤ÊÅ¢Âæ©Á∂≤Áµ°ÈÄ£Êé•', 'success');
      });
      
      window.addEventListener('offline', () => {
        showNotification('Â∑≤ÈÄ≤ÂÖ•Èõ¢Á∑öÊ®°Âºè', 'info');
      });
      
      // Â¶ÇÊûúÂ∑≤Á∂ìÈõ¢Á∑öÔºåÈ°ØÁ§∫ÊèêÁ§∫
      if (!navigator.onLine) {
        showNotification('Áï∂ÂâçËôïÊñºÈõ¢Á∑öÊ®°Âºè', 'info');
      }
    }
    
    // ÂàùÂßãÂåñÊáâÁî®
    setupOfflineSupport();
    initApp();
  </script>
</body>
</html>