<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>iPadå…‰è­œåˆ†æå·¥å…·</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    :root {
      --primary-color: #3b82f6;
      --primary-dark: #2563eb;
      --secondary-color: #22c55e;
      --secondary-dark: #16a34a;
      --danger-color: #ef4444;
      --danger-dark: #dc2626;
      --background-color: #f8fafc;
      --text-color: #0f172a;
      --border-color: #cbd5e1;
      --border-radius: 10px;
      --safe-area-inset-top: env(safe-area-inset-top, 0px);
      --safe-area-inset-bottom: env(safe-area-inset-bottom, 20px);
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 0;
      background-color: var(--background-color);
      color: var(--text-color);
      overscroll-behavior-y: none;
      touch-action: manipulation;
      padding: 0 12px;
      padding-top: calc(var(--safe-area-inset-top) + 12px);
      padding-bottom: calc(var(--safe-area-inset-bottom) + 12px);
    }
    
    .container {
      max-width: 100%;
      margin: 0 auto;
      padding-bottom: 30px;
    }
    
    .header {
      text-align: center;
      padding: 15px 0;
      margin-bottom: 20px;
      position: sticky;
      top: 0;
      background-color: var(--background-color);
      z-index: 10;
    }
    
    h1 {
      font-size: 24px;
      margin: 0;
      font-weight: 600;
    }
    
    .canvas-container {
      position: relative;
      width: 100%;
      max-width: 800px;
      margin: 0 auto 20px auto;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      border-radius: var(--border-radius);
      overflow: hidden;
    }
    
    canvas {
      display: block;
      width: 100%;
      height: auto;
      border-radius: var(--border-radius);
      touch-action: none;
    }
    
    .input-group {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
      gap: 10px;
    }
    
    .file-input-wrapper {
      display: flex;
      width: 100%;
      flex-direction: column;
      gap: 10px;
    }
    
    .file-buttons {
      display: flex;
      gap: 10px;
    }
    
    .section {
      background-color: white;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: var(--border-radius);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    
    .section-title {
      font-size: 18px;
      font-weight: 600;
      margin-top: 0;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .slider-container {
      margin-bottom: 15px;
    }
    
    .slider-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-weight: 500;
    }
    
    .slider-value {
      font-family: monospace;
      background-color: var(--background-color);
      padding: 5px 8px;
      border-radius: 5px;
      font-weight: normal;
    }
    
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 10px;
      border-radius: 5px;
      background-color: #e2e8f0;
      outline: none;
      transition: background 0.2s;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: var(--primary-color);
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transition: background 0.2s;
    }
    
    input[type="range"]::-webkit-slider-thumb:active {
      background: var(--primary-dark);
      transform: scale(1.1);
    }
    
    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 15px;
      margin-bottom: 5px;
    }
    
    button {
      -webkit-appearance: none;
      appearance: none;
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 12px 20px;
      font-size: 16px;
      font-weight: 500;
      border-radius: var(--border-radius);
      cursor: pointer;
      flex: 1 0 auto;
      min-width: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    
    button:active {
      background-color: var(--primary-dark);
      transform: translateY(1px);
    }
    
    .btn-secondary {
      background-color: var(--secondary-color);
    }
    
    .btn-secondary:active {
      background-color: var(--secondary-dark);
    }
    
    .btn-danger {
      background-color: var(--danger-color);
    }
    
    .btn-danger:active {
      background-color: var(--danger-dark);
    }
    
    .btn-outline {
      background-color: transparent;
      color: var(--primary-color);
      border: 2px solid var(--primary-color);
    }
    
    .btn-outline:active {
      background-color: rgba(59, 130, 246, 0.1);
    }
    
    .btn-icon {
      width: 44px;
      min-width: auto;
      padding: 10px;
    }
    
    .plot-container {
      width: 100%;
      height: 300px;
      margin-top: 20px;
      margin-bottom: 10px;
    }
    
    .calibration-form {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    
    .calibration-input {
      flex: 1;
      min-width: 180px;
      display: flex;
      align-items: center;
    }
    
    input[type="number"] {
      display: block;
      width: 100%;
      padding: 12px;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      font-size: 16px;
      background-color: white;
    }
    
    input[type="number"]:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 15px;
    }
    
    table th,
    table td {
      padding: 12px 10px;
      text-align: center;
      border: 1px solid var(--border-color);
    }
    
    table th {
      background-color: #f1f5f9;
      font-weight: 600;
    }
    
    table tr:nth-child(even) {
      background-color: #f8fafc;
    }
    
    .cal-result {
      padding: 10px;
      background-color: #f1f5f9;
      border-radius: var(--border-radius);
      font-weight: 500;
      text-align: center;
      margin-bottom: 15px;
    }
    
    /* iPadç‰¹å®šæ¨£å¼ */
    @media only screen and (min-width: 768px) {
      .container {
        padding: 20px;
        max-width: 1000px;
      }
      
      .two-column {
        display: flex;
        gap: 20px;
      }
      
      .column {
        flex: 1;
      }
      
      .plot-container {
        height: 400px;
      }
      
      button {
        padding: 12px 24px;
      }
    }
    
    /* iPadæ©«å‘æ¨¡å¼ */
    @media only screen and (min-width: 1024px) {
      .container {
        padding: 30px;
      }
      
      .canvas-container {
        max-height: 500px;
      }
    }
    
    /* æ·±è‰²æ¨¡å¼æ”¯æ´ */
    @media (prefers-color-scheme: dark) {
      :root {
        --background-color: #0f172a;
        --text-color: #f8fafc;
        --border-color: #334155;
      }
      
      .section {
        background-color: #1e293b;
      }
      
      input[type="range"] {
        background-color: #334155;
      }
      
      input[type="number"] {
        background-color: #1e293b;
        color: var(--text-color);
      }
      
      table th {
        background-color: #334155;
      }
      
      table tr:nth-child(even) {
        background-color: #1e293b;
      }
      
      .cal-result {
        background-color: #334155;
      }
      
      .slider-value {
        background-color: #1e293b;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>ğŸ“± iPadå…‰è­œåˆ†æå·¥å…·</h1>
    </div>
    
    <div class="section">
      <h2 class="section-title">åœ–åƒè¼¸å…¥</h2>
      
      <div class="file-input-wrapper">
        <div class="file-buttons">
          <button id="selectPhotoBtn" class="btn-secondary">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M4 16L8.586 11.414C8.96106 11.0391 9.46967 10.8284 10 10.8284C10.5303 10.8284 11.0389 11.0391 11.414 11.414L16 16M14 14L15.586 12.414C15.9611 12.0391 16.4697 11.8284 17 11.8284C17.5303 11.8284 18.0389 12.0391 18.414 12.414L20 14M14 8H14.01M6 20H18C19.1046 20 20 19.1046 20 18V6C20 4.89543 19.1046 4 18 4H6C4.89543 4 4 4.89543 4 6V18C4 19.1046 4.89543 20 6 20Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            é¸æ“‡ç›¸ç‰‡
          </button>
          <button id="takePictureBtn" class="btn-secondary">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M3 9C3 7.89543 3.89543 7 5 7H5.92963C6.59834 7 7.2228 6.6658 7.59373 6.1094L8.40627 4.8906C8.7772 4.3342 9.40166 4 10.0704 4H13.9296C14.5983 4 15.2228 4.3342 15.5937 4.8906L16.4063 6.1094C16.7772 6.6658 17.4017 7 18.0704 7H19C20.1046 7 21 7.89543 21 9V18C21 19.1046 20.1046 20 19 20H5C3.89543 20 3 19.1046 3 18V9Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            æ‹æ”ç…§ç‰‡
          </button>
        </div>
        <input type="file" id="imgInput" accept="image/*" style="display:none;" />
      </div>
      
      <div class="canvas-container">
        <canvas id="preview" touch-action="none"></canvas>
      </div>
    </div>
    
    <div class="section">
      <h2 class="section-title">é¸æ“‡å€åŸŸ</h2>
      
      <div class="slider-container">
        <div class="slider-label">
          X èµ·é» <span class="slider-value" id="xStartVal">00000</span>
        </div>
        <input type="range" id="xStart" min="0" max="100" value="0" />
      </div>
      
      <div class="slider-container">
        <div class="slider-label">
          X çµ‚é» <span class="slider-value" id="xEndVal">00100</span>
        </div>
        <input type="range" id="xEnd" min="0" max="100" value="100" />
      </div>
      
      <div class="button-row">
        <button id="analyzeBtn" class="btn-primary">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M9 17L15 11L9 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          åˆ†æå…‰è­œ
        </button>
      </div>
      
      <div id="plot" class="plot-container"></div>
    </div>
    
    <div class="section">
      <h2 class="section-title">æ³¢é•·æ ¡æ­£</h2>
      
      <div class="slider-container">
        <div class="slider-label">
          ğŸ¯ æ ¡æ­£ç•«ç´  <span class="slider-value" id="xCalibrateVal">00050</span>
        </div>
        <input type="range" id="xCalibrate" min="0" max="100" value="50" />
      </div>
      
      <div class="calibration-form">
        <div class="calibration-input">
          <label for="wavelengthInput">å°æ‡‰æ³¢é•· (nm)</label>
          <input type="number" id="wavelengthInput" inputmode="decimal" />
        </div>
        
        <button id="addPointBtn" class="btn-primary">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 4V20M4 12H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          åŠ å…¥æ ¡æ­£é»
        </button>
      </div>
      
      <table id="calibrationTable">
        <thead>
          <tr>
            <th>#</th>
            <th>ç•«ç´ ä½ç½®</th>
            <th>æ³¢é•· (nm)</th>
            <th>æ“ä½œ</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      
      <div class="button-row">
        <button id="generateRegressionBtn" class="btn-secondary">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M7 15L12 10L17 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M3 10L12 3L21 10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M3 21H21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          ç”¢ç”Ÿæ ¡æ­£å›æ­¸ç·š
        </button>
      </div>
      
      <div class="cal-result" id="regressionResult">å°šæœªæ ¡æ­£</div>
    </div>
    
    <div class="section">
      <h2 class="section-title">æ³¢é•·å¼·åº¦åœ–</h2>
      
      <div class="button-row">
        <button id="plotWavelengthBtn" class="btn-primary">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M21 21H3V3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M20 7L14 13L10 9L4 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          é¡¯ç¤ºå¼·åº¦ï¼æ³¢é•·åœ–
        </button>
        <button id="toggleBackgroundBtn" class="btn-outline">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M4 16L8.586 11.414C8.96106 11.0391 9.46967 10.8284 10 10.8284C10.5303 10.8284 11.0389 11.0391 11.414 11.414L16 16M14 14L15.586 12.414C15.9611 12.0391 16.4697 11.8284 17 11.8284C17.5303 11.8284 18.0389 12.0391 18.414 12.414L20 14M14 8H14.01M6 20H18C19.1046 20 20 19.1046 20 18V6C20 4.89543 19.1046 4 18 4H6C4.89543 4 4 4.89543 4 6V18C4 19.1046 4.89543 20 6 20Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          åŠ å…¥èƒŒæ™¯åœ–
        </button>
      </div>
      
      <div id="wavelengthPlot" class="plot-container"></div>
    </div>
  </div>

  <script>
    // DOMå…ƒç´ 
    const canvas = document.getElementById("preview");
    const ctx = canvas.getContext("2d", { alpha: false });
    const imgInput = document.getElementById("imgInput");
    const selectPhotoBtn = document.getElementById("selectPhotoBtn");
    const takePictureBtn = document.getElementById("takePictureBtn");
    const xStartSlider = document.getElementById("xStart");
    const xEndSlider = document.getElementById("xEnd");
    const xCalibrateSlider = document.getElementById("xCalibrate");
    const xStartVal = document.getElementById("xStartVal");
    const xEndVal = document.getElementById("xEndVal");
    const xCalibrateVal = document.getElementById("xCalibrateVal");
    const wavelengthInput = document.getElementById("wavelengthInput");
    const analyzeBtn = document.getElementById("analyzeBtn");
    const addPointBtn = document.getElementById("addPointBtn");
    const generateRegressionBtn = document.getElementById("generateRegressionBtn");
    const plotWavelengthBtn = document.getElementById("plotWavelengthBtn");
    const toggleBackgroundBtn = document.getElementById("toggleBackgroundBtn");
    const regressionResult = document.getElementById("regressionResult");
    
    // å…¨å±€è®Šé‡
    const img = new Image();
    let calibrationPoints = [];
    let calibration = null;
    let regressionConfirmed = false;
    let imageData, rawData, width, height;
    let backgroundImageOn = false;
    let isGestureDetected = false;
    let lastTouchDistance = 0;
    let touchStartX = 0;
    let canvasDimensions = { offsetX: 0, offsetY: 0, drawWidth: 0, drawHeight: 0 };
    
    // è¨­ç½®ç•«å¸ƒä»¥é©æ‡‰è¨­å‚™é¡¯ç¤º
    function setupCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const container = canvas.parentElement;
      const containerWidth = container.clientWidth;
      
      // è¨­ç½®ç•«å¸ƒçš„å¯¦éš›å°ºå¯¸
      canvas.width = containerWidth * dpr;
      canvas.height = (containerWidth * 0.75) * dpr; // ä¿æŒ4:3æˆ–16:9çš„æ¯”ä¾‹
      
      // ä¿æŒé¡¯ç¤ºå°ºå¯¸ä¸è®Š
      canvas.style.width = `${containerWidth}px`;
      canvas.style.height = `${containerWidth * 0.75}px`;
      
      // èª¿æ•´ç¹ªåœ–ä¸Šä¸‹æ–‡æ¯”ä¾‹
      ctx.scale(dpr, dpr);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
    }
    
    // ä¿æŒåœ–ç‰‡æ¯”ä¾‹ç¹ªè£½
    function drawImageMaintainAspect(img, ctx, canvas) {
      const dpr = window.devicePixelRatio || 1;
      const canvasWidth = canvas.width / dpr;
      const canvasHeight = canvas.height / dpr;
      const imgRatio = img.naturalWidth / img.naturalHeight;
      const canvasRatio = canvasWidth / canvasHeight;
      
      let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
      
      if (imgRatio > canvasRatio) {
        // åœ–ç‰‡æ¯”ç•«å¸ƒæ›´å¯¬
        drawWidth = canvasWidth;
        drawHeight = canvasWidth / imgRatio;
        offsetY = (canvasHeight - drawHeight) / 2;
      } else {
        // åœ–ç‰‡æ¯”ç•«å¸ƒæ›´é«˜æˆ–ç­‰æ¯”ä¾‹
        drawHeight = canvasHeight;
        drawWidth = canvasHeight * imgRatio;
        offsetX = (canvasWidth - drawWidth) / 2;
      }
      
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
      
      canvasDimensions = { offsetX, offsetY, drawWidth, drawHeight };
      return canvasDimensions;
    }
    
    // äº”ä½æ•¸æ ¼å¼åŒ–
    function formatNumber(n) {
      return n.toString().padStart(5, "0");
    }
    
    // æ›´æ–°æ»‘æ¡¿
    function updateSliders(max) {
      [xStartSlider, xEndSlider, xCalibrateSlider].forEach(slider => {
        slider.max = max;
      });
      xStartSlider.value = 0;
      xEndSlider.value = max;
      xCalibrateSlider.value = Math.floor(max / 2);
      syncSliderValues();
    }
    
    // åŒæ­¥æ»‘æ¡¿å€¼
    function syncSliderValues() {
      let x1 = parseInt(xStartSlider.value);
      let x2 = parseInt(xEndSlider.value);
      if (x2 < x1) [x1, x2] = [x2, x1];
      
      xStartVal.textContent = formatNumber(x1);
      xEndVal.textContent = formatNumber(x2);
      xCalibrateVal.textContent = formatNumber(xCalibrateSlider.value);
      
      xCalibrateSlider.min = x1;
      xCalibrateSlider.max = x2;
      
      // ä½¿ç”¨requestAnimationFrameä¾†ç¢ºä¿ç•«é¢æ›´æ–°
      requestAnimationFrame(drawWithRectangle);
    }
    
    // ç¹ªè£½æ–¹æ¡†
    function drawWithRectangle() {
      if (!img.complete || img.naturalWidth === 0) return;
      
      const dpr = window.devicePixelRatio || 1;
      const canvasWidth = canvas.width / dpr;
      const canvasHeight = canvas.height / dpr;
      
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      const { offsetX, offsetY, drawWidth, drawHeight } = drawImageMaintainAspect(img, ctx, canvas);
      
      let x1 = parseInt(xStartSlider.value);
      let x2 = parseInt(xEndSlider.value);
      if (x2 < x1) [x1, x2] = [x2, x1];
      
      // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹
      let xScale = drawWidth / width;
      let yScale = drawHeight / height;
      
      // ä½¿ç”¨æ•´æ•¸ä½ç½®+0.5ä¾†ç¹ªè£½æ›´æ¸…æ™°çš„ç·šæ¢
      let rectX1 = Math.floor(offsetX + x1 * xScale) + 0.5;
      let rectX2 = Math.floor(offsetX + x2 * xScale) + 0.5;
      let rectY1 = Math.floor(offsetY + height * 0.45 * yScale) + 0.5;
      let rectY2 = Math.floor(offsetY + height * 0.55 * yScale) + 0.5;
      
      ctx.strokeStyle = "yellow";
      ctx.lineWidth = 2;
      
      // ä½¿ç”¨è·¯å¾‘ä¾†ç¹ªè£½æ›´ç²¾ç¢ºçš„çŸ©å½¢
      ctx.beginPath();
      ctx.moveTo(rectX1, rectY1);
      ctx.lineTo(rectX2, rectY1);
      ctx.lineTo(rectX2, rectY2);
      ctx.lineTo(rectX1, rectY2);
      ctx.closePath();
      ctx.stroke();
    }
    
    // æå–å’Œç¹ªè£½å¼·åº¦åœ–
    function extractAndPlot() {
      if (!rawData) {
        showNotification("è«‹å…ˆä¸Šå‚³åœ–ç‰‡ï¼");
        return;
      }
      
      let x1 = parseInt(xStartSlider.value);
      let x2 = parseInt(xEndSlider.value);
      if (x2 < x1) [x1, x2] = [x2, x1];
      let y1 = Math.floor(height * 0.45) + 2;
      let y2 = Math.floor(height * 0.55) - 2;
      
      let dataX = [], dataY = [];
      
      for (let x = x1; x <= x2; x++) {
        let sum = 0;
        for (let y = y1; y <= y2; y++) {
          let idx = (y * width + x) * 4;
          if (idx < rawData.length) {
            let r = rawData[idx];
            let g = rawData[idx + 1];
            let b = rawData[idx + 2];
            let intensity = (r + g + b) / 3;
            sum += intensity;
          }
        }
        let avg = sum / (y2 - y1 + 1);
        dataX.push(x);
        dataY.push(avg);
      }
      
      let shapes = [{
        type: "line",
        x0: parseInt(xCalibrateSlider.value),
        x1: parseInt(xCalibrateSlider.value),
        y0: 0,
        y1: Math.max(...dataY),
        line: { color: "red", width: 2, dash: "dot" }
      }];
      
      // ä½¿ç”¨Plotlyç¹ªè£½é©åˆè§¸æ§æ“ä½œçš„åœ–è¡¨
      Plotly.newPlot("plot", [{
        x: dataX,
        y: dataY,
        mode: "lines",
        name: "åƒç´ å¼·åº¦",
        line: { color: "#3b82f6", width: 3 }
      }], {
        margin: { t: 20, r: 20, b: 40, l: 50 },
        xaxis: { 
          title: "åƒç´ ä½ç½®",
          showline: true,
          mirror: true,
          ticks: 'outside',
          linecolor: 'black',
          linewidth: 2,
          tickfont: { size: 14 }
        },
        yaxis: { 
          title: "å¼·åº¦",
          showline: true,
          mirror: true,
          ticks: 'outside',
          linecolor: 'black',
          linewidth: 2,
          tickfont: { size: 14 }
        },
        shapes: shapes,
        dragmode: 'pan',
        modeBarButtonsToAdd: [
          'hoverClosestCartesian',
          'hoverCompareCartesian',
          'toggleSpikelines'
        ],
        hovermode: 'closest',
        colorway: ['#3b82f6', '#ef4444', '#22c55e'],
        plot_bgcolor: 'rgba(255,255,255,0)',
        paper_bgcolor: 'rgba(255,255,255,0)'
      }, { 
        displayModeBar: true, 
        responsive: true,
        toImageButtonOptions: {
          format: 'png',
          filename: 'spectrum_intensity',
          scale: 2
        },
        modeBarButtonsToRemove: [
          'lasso2d', 
          'select2d',
          'autoScale2d'
        ]
      });
    }
    
    // æ›´æ–°æ ¡æ­£è¡¨æ ¼
    function updateCalibrationTable() {
      const tbody = document.querySelector("#calibrationTable tbody");
      tbody.innerHTML = "";
      
      calibrationPoints.forEach((p, index) => {
        const row = document.createElement("tr");
        
        const cellIndex = document.createElement("td");
        const cellPixel = document.createElement("td");
        const cellWavelength = document.createElement("td");
        const cellDelete = document.createElement("td");
        
        cellIndex.textContent = index + 1;
        cellPixel.textContent = p.pixel;
        cellWavelength.textContent = p.wavelength.toFixed(2);
        
        const deleteBtn = document.createElement("button");
        deleteBtn.textContent = "âŒ";
        deleteBtn.classList.add("btn-danger", "btn-icon");
        deleteBtn.onclick = (e) => {
          e.preventDefault();
          calibrationPoints.splice(index, 1);
          regressionConfirmed = false;
          calibration = null;
          regressionResult.textContent = "å°šæœªæ ¡æ­£";
          updateCalibrationTable();
        };
        
        cellDelete.appendChild(deleteBtn);
        
        row.appendChild(cellIndex);
        row.appendChild(cellPixel);
        row.appendChild(cellWavelength);
        row.appendChild(cellDelete);
        tbody.appendChild(row);
      });
    }
    
    // ç²å–é¸å®šç¯„åœçš„åœ–åƒæ•¸æ“šURL
    function getSelectedImageDataURL(x1, x2, y1, y2) {
      const cropCanvas = document.createElement("canvas");
      const cropCtx = cropCanvas.getContext("2d");
      const cropWidth = x2 - x1 + 1;
      const cropHeight = y2 - y1 + 1;
      
      cropCanvas.width = cropWidth;
      cropCanvas.height = cropHeight;
      
      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = width;
      tempCanvas.height = height;
      const tempCtx = tempCanvas.getContext("2d");
      tempCtx.putImageData(imageData, 0, 0);
      
      try {
        const cropImageData = tempCtx.getImageData(x1, y1, cropWidth, cropHeight);
        cropCtx.putImageData(cropImageData, 0, 0);
        return cropCanvas.toDataURL();
      } catch (e) {
        console.error("è£å‰ªåœ–åƒç™¼ç”ŸéŒ¯èª¤:", e);
        return null;
      }
    }
    
    // ç¹ªè£½æ³¢é•·å¼·åº¦åœ–
    function plotWavelengthGraph() {
      if (!rawData) {
        showNotification("è«‹å…ˆä¸Šå‚³åœ–ç‰‡ï¼");
        return;
      }
      
      if (!calibration) {
        showNotification("è«‹å…ˆåŠ å…¥è‡³å°‘å…©å€‹æ ¡æ­£é»ï¼Œä¸¦å®Œæˆæ ¡æ­£ï¼");
        return;
      }
      
      let x1 = parseInt(xStartSlider.value);
      let x2 = parseInt(xEndSlider.value);
      if (x2 < x1) [x1, x2] = [x2, x1];
      let y1 = Math.floor(height * 0.45) + 2;
      let y2 = Math.floor(height * 0.55) - 2;
      
      let dataX = [], dataY = [];
      
      for (let x = x1; x <= x2; x++) {
        let sum = 0;
        for (let y = y1; y <= y2; y++) {
          let idx = (y * width + x) * 4;
          if (idx < rawData.length) {
            let r = rawData[idx];
            let g = rawData[idx + 1];
            let b = rawData[idx + 2];
            let intensity = (r + g + b) / 3;
            sum += intensity;
          }
        }
        let avg = sum / (y2 - y1 + 1);
        dataX.push(x);
        dataY.push(avg);
      }
      
      const { a, b } = calibration;
      let wavelengthX = dataX.map(x => a * x + b);
      
      Plotly.newPlot("wavelengthPlot", [{
        x: wavelengthX,
        y: dataY,
        mode: "lines",
        name: "æ³¢é•·å¼·åº¦",
        line: { color: "#22c55e", width: 3 }
      }], {
        margin: { t: 20, r: 20, b: 40, l: 50 },
        xaxis: {
          title: "æ³¢é•· (nm)",
          showline: true,
          mirror: true,
          ticks: 'outside',
          linecolor: 'black',
          linewidth: 2,
          tickfont: { size: 14 }
        },
        yaxis: {
          title: "å¼·åº¦",
          showline: true,
          mirror: true,
          ticks: 'outside',
          linecolor: 'black',
          linewidth: 2,
          tickfont: { size: 14 }
        },
        dragmode: 'pan',
        modeBarButtonsToAdd: [
          'hoverClosestCartesian',
          'hoverCompareCartesian',
          'toggleSpikelines'
        ],
        hovermode: 'closest',
        images: [],
        plot_bgcolor: 'rgba(255,255,255,0)',
        paper_bgcolor: 'rgba(255,255,255,0)'
      }, { 
        displayModeBar: true, 
        responsive: true,
        toImageButtonOptions: {
          format: 'png',
          filename: 'spectrum_wavelength',
          scale: 2
        },
        modeBarButtonsToRemove: [
          'lasso2d', 
          'select2d',
          'autoScale2d'
        ]
      });
      
      // é‡ç½®èƒŒæ™¯åœ–ç‹€æ…‹
      backgroundImageOn = false;
      toggleBackgroundBtn.textContent = "ğŸ–¼ åŠ å…¥èƒŒæ™¯åœ–";
      toggleBackgroundBtn.classList.add("btn-outline");
      toggleBackgroundBtn.classList.remove("btn-danger");
    }
    
    // åˆ‡æ›èƒŒæ™¯åœ–
    function toggleBackground() {
      if (!rawData || !calibration) {
        showNotification("è«‹å…ˆåŠ å…¥è‡³å°‘å…©å€‹æ ¡æ­£é»ï¼Œä¸¦å®Œæˆæ ¡æ­£ï¼");
        return;
      }
      
      let x1 = parseInt(xStartSlider.value);
      let x2 = parseInt(xEndSlider.value);
      if (x2 < x1) [x1, x2] = [x2, x1];
      let y1 = Math.floor(height * 0.45) + 2;
      let y2 = Math.floor(height * 0.55) - 2;
      
      const { a, b } = calibration;
      const wlStart = a * x1 + b;
      const wlEnd = a * x2 + b;
      
      if (!backgroundImageOn) {
        // åŠ å…¥èƒŒæ™¯åœ–
        const imageDataUrl = getSelectedImageDataURL(x1, x2, y1, y2);
        
        if (imageDataUrl) {
          const bgImage = {
            source: imageDataUrl,
            xref: "x",
            yref: "paper",
            x: wlStart,
            y: 1,
            sizex: wlEnd - wlStart,
            sizey: 1,
            sizing: "stretch",
            opacity: 0.6,
            layer: "below"
          };
          
          Plotly.relayout("wavelengthPlot", {
            images: [bgImage]
          });
          
          backgroundImageOn = true;
          toggleBackgroundBtn.textContent = "ğŸš« ç§»é™¤èƒŒæ™¯åœ–";
          toggleBackgroundBtn.classList.remove("btn-outline");
          toggleBackgroundBtn.classList.add("btn-danger");
        } else {
          showNotification("ç„¡æ³•ç”ŸæˆèƒŒæ™¯åœ–ç‰‡ï¼Œè«‹æª¢æŸ¥é¸æ“‡ç¯„åœï¼");
        }
      } else {
        // ç§»é™¤èƒŒæ™¯åœ–
        Plotly.relayout("wavelengthPlot", {
          images: []
        });
        
        backgroundImageOn = false;
        toggleBackgroundBtn.textContent = "ğŸ–¼ åŠ å…¥èƒŒæ™¯åœ–";
        toggleBackgroundBtn.classList.add("btn-outline");
        toggleBackgroundBtn.classList.remove("btn-danger");
      }
    }
    
    // åœ–ç‰‡åŠ è¼‰è™•ç†
    function loadImageFromFile(file) {
      if (!file) return;
      
      const reader = new FileReader();
      
      reader.onload = function(e) {
        img.onload = function() {
          width = img.naturalWidth;
          height = img.naturalHeight;
          
          setupCanvas();
          
          updateSliders(width - 1);
          
          // ä½¿ç”¨Promiseç¢ºä¿åœ–ç‰‡å®Œå…¨è§£ç¢¼å¾Œå†è™•ç†
          if (img.decode) {
            img.decode().then(() => {
              processLoadedImage();
            }).catch(err => {
              console.error("åœ–ç‰‡è§£ç¢¼å¤±æ•—:", err);
              processLoadedImage();
            });
          } else {
            processLoadedImage();
          }
        };
        
        img.src = e.target.result;
      };
      
      reader.readAsDataURL(file);
    }
    
    // è™•ç†åŠ è¼‰å¥½çš„åœ–ç‰‡
    function processLoadedImage() {
      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = width;
      tempCanvas.height = height;
      const tempCtx = tempCanvas.getContext("2d");
      tempCtx.drawImage(img, 0, 0);
      
      try {
        imageData = tempCtx.getImageData(0, 0, width, height);
        rawData = imageData.data;
        
        drawWithRectangle();
        showNotification("åœ–ç‰‡å·²æˆåŠŸè¼‰å…¥", "success");
      } catch (e) {
        console.error("è™•ç†åœ–ç‰‡æ™‚ç™¼ç”ŸéŒ¯èª¤:", e);
        showNotification("åœ–ç‰‡è™•ç†å¤±æ•—ï¼Œè«‹å˜—è©¦ä½¿ç”¨å…¶ä»–åœ–ç‰‡ã€‚", "error");
      }
    }
    
    // æ·»åŠ æ ¡æ­£é»
    function addCalibrationPoint() {
      const pixel = parseInt(xCalibrateSlider.value);
      const wavelength = parseFloat(wavelengthInput.value);
      
      if (isNaN(pixel) || isNaN(wavelength)) {
        showNotification("è«‹è¼¸å…¥æœ‰æ•ˆçš„ç•«ç´ èˆ‡æ³¢é•·ï¼", "error");
        return;
      }
      
      calibrationPoints.push({ pixel, wavelength });
      regressionConfirmed = false;
      calibration = null;
      regressionResult.textContent = "å°šæœªæ ¡æ­£";
      updateCalibrationTable();
      showNotification("å·²åŠ å…¥æ ¡æ­£é»", "success");
      wavelengthInput.value = "";
    }
    
    // ç”Ÿæˆå›æ­¸ç·š
    function generateRegression() {
      if (calibrationPoints.length < 2) {
        showNotification("è«‹è‡³å°‘è¼¸å…¥å…©å€‹æ ¡æ­£é»ï¼", "error");
        return;
      }
      
      // ä½¿ç”¨æ‰€æœ‰æ ¡æ­£é»é€²è¡Œç·šæ€§å›æ­¸
      let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
      const n = calibrationPoints.length;
      
      calibrationPoints.forEach(p => {
        sumX += p.pixel;
        sumY += p.wavelength;
        sumXY += p.pixel * p.wavelength;
        sumX2 += p.pixel * p.pixel;
      });
      
      const a = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      const b = (sumY - a * sumX) / n;
      
      calibration = { a, b };
      regressionConfirmed = true;
      
      regressionResult.textContent = `Î» = ${a.toFixed(4)} Ã— x + ${b.toFixed(2)}`;
      showNotification("å·²ç”Ÿæˆæ ¡æ­£æ–¹ç¨‹å¼", "success");
    }
    
    // é¡¯ç¤ºé€šçŸ¥æç¤º
    function showNotification(message, type = "info") {
      // å‰µå»ºé€šçŸ¥å…ƒç´ 
      const notification = document.createElement("div");
      notification.textContent = message;
      notification.style.position = "fixed";
      notification.style.bottom = "20px";
      notification.style.left = "50%";
      notification.style.transform = "translateX(-50%)";
      notification.style.padding = "12px 20px";
      notification.style.borderRadius = "8px";
      notification.style.fontWeight = "500";
      notification.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.15)";
      notification.style.zIndex = "9999";
      notification.style.maxWidth = "80%";
      notification.style.textAlign = "center";
      
      // è¨­ç½®ä¸åŒé¡å‹çš„æ¨£å¼
      switch(type) {
        case "success":
          notification.style.backgroundColor = "#22c55e";
          notification.style.color = "white";
          break;
        case "error":
          notification.style.backgroundColor = "#ef4444";
          notification.style.color = "white";
          break;
        default:
          notification.style.backgroundColor = "#3b82f6";
          notification.style.color = "white";
      }
      
      // æ·»åŠ åˆ°é é¢ä¸¦åœ¨2ç§’å¾Œç§»é™¤
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.opacity = "0";
        notification.style.transition = "opacity 0.5s ease";
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 500);
      }, 2000);
    }
    
    // å¤šé»è§¸æ§æ‰‹å‹¢è™•ç†
    function setupGestureEvents() {
      // è§¸æ§é–‹å§‹
      canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
          // å…©æŒ‡è§¸æ§ï¼Œæº–å‚™é€²è¡Œç¸®æ”¾æˆ–æ»‘å‹•
          isGestureDetected = true;
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          lastTouchDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );
          touchStartX = (touch1.clientX + touch2.clientX) / 2;
        } else if (e.touches.length === 1) {
          // å–®æŒ‡è§¸æ§ï¼Œæº–å‚™ç§»å‹•æ ¡æ­£é»
          touchStartX = e.touches[0].clientX;
        }
        e.preventDefault();
      }, { passive: false });
      
      // è§¸æ§ç§»å‹•
      canvas.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2 && isGestureDetected) {
          // å…©æŒ‡æ‰‹å‹¢è™•ç†
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const touchDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );
          
          // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹
          const scale = touchDistance / lastTouchDistance;
          lastTouchDistance = touchDistance;
          
          // è¨ˆç®—ä¸­å¿ƒé»
          const touchCenterX = (touch1.clientX + touch2.clientX) / 2;
          const touchDeltaX = touchCenterX - touchStartX;
          touchStartX = touchCenterX;
          
          // æ‡‰ç”¨ç¸®æ”¾æˆ–å¹³ç§»åˆ°æ»‘æ¡¿æ§ä»¶
          if (Math.abs(scale - 1) > 0.05) {
            // ç¸®æ”¾æ“ä½œ - èª¿æ•´é–‹å§‹å’ŒçµæŸé»çš„è·é›¢
            const x1 = parseInt(xStartSlider.value);
            const x2 = parseInt(xEndSlider.value);
            const range = x2 - x1;
            const midPoint = (x1 + x2) / 2;
            
            const newRange = Math.max(10, Math.min(width - 1, range * scale));
            const newX1 = Math.max(0, Math.round(midPoint - newRange / 2));
            const newX2 = Math.min(width - 1, Math.round(midPoint + newRange / 2));
            
            xStartSlider.value = newX1;
            xEndSlider.value = newX2;
            syncSliderValues();
          } else if (Math.abs(touchDeltaX) > 5) {
            // å¹³ç§»æ“ä½œ - ä¿æŒç¯„åœä¸è®Šä½†ç§»å‹•ä½ç½®
            const x1 = parseInt(xStartSlider.value);
            const x2 = parseInt(xEndSlider.value);
            const range = x2 - x1;
            
            // å°‡è§¸æ§ç§»å‹•è½‰æ›ç‚ºåƒç´ ç§»å‹•
            const pixelDelta = Math.round(touchDeltaX * width / canvas.clientWidth);
            
            if (Math.abs(pixelDelta) > 0) {
              let newX1 = x1 + pixelDelta;
              let newX2 = x2 + pixelDelta;
              
              // ä¿è­‰ä¸è¶…å‡ºé‚Šç•Œ
              if (newX1 < 0) {
                newX1 = 0;
                newX2 = range;
              }
              
              if (newX2 > width - 1) {
                newX2 = width - 1;
                newX1 = newX2 - range;
              }
              
              xStartSlider.value = newX1;
              xEndSlider.value = newX2;
              syncSliderValues();
            }
          }
        } else if (e.touches.length === 1 && !isGestureDetected) {
          // å–®æŒ‡ç§»å‹• - ç§»å‹•æ ¡æ­£é»
          const touch = e.touches[0];
          const touchDeltaX = touch.clientX - touchStartX;
          touchStartX = touch.clientX;
          
          // å°‡è§¸æ§ç§»å‹•è½‰æ›ç‚ºåƒç´ ç§»å‹•
          const pixelDelta = Math.round(touchDeltaX * width / canvas.clientWidth);
          
          if (Math.abs(pixelDelta) > 0) {
            const newPosition = parseInt(xCalibrateSlider.value) + pixelDelta;
            xCalibrateSlider.value = Math.max(xCalibrateSlider.min, Math.min(xCalibrateSlider.max, newPosition));
            syncSliderValues();
            if (rawData) extractAndPlot();
          }
        }
        e.preventDefault();
      }, { passive: false });
      
      // è§¸æ§çµæŸ
      canvas.addEventListener('touchend', (e) => {
        isGestureDetected = false;
        
        // å¦‚æœä¹‹å‰æ˜¯åœ¨æ‹–æ”¾æ ¡æ­£é»ä¸¦ä¸”é‚„æœ‰æ¿€æ´»çš„è§¸æ§ï¼Œæ›´æ–°åœ–è¡¨
        if (e.touches.length === 0 && rawData) {
          extractAndPlot();
        }
      });
      
      // é˜»æ­¢ç¸®æ”¾
      canvas.addEventListener('gesturestart', (e) => {
        e.preventDefault();
      }, { passive: false });
    }
    
    // ç›¸æ©Ÿæ•´åˆ - æ‹æ”åœ–ç‰‡
    function setupCameraIntegration() {
      // æª¢æŸ¥æ˜¯å¦æ”¯æ´getUserMedia
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        takePictureBtn.addEventListener('click', () => {
          // å‰µå»ºç›¸æ©Ÿå…ƒç´ 
          const videoElement = document.createElement('video');
          videoElement.setAttribute('autoplay', '');
          videoElement.setAttribute('playsinline', '');
          videoElement.style.display = 'none';
          document.body.appendChild(videoElement);
          
          // å‰µå»ºæ‹ç…§ç•Œé¢
          const cameraContainer = document.createElement('div');
          cameraContainer.style.position = 'fixed';
          cameraContainer.style.top = '0';
          cameraContainer.style.left = '0';
          cameraContainer.style.width = '100%';
          cameraContainer.style.height = '100%';
          cameraContainer.style.backgroundColor = 'black';
          cameraContainer.style.zIndex = '10000';
          cameraContainer.style.display = 'flex';
          cameraContainer.style.flexDirection = 'column';
          
          const cameraPreview = document.createElement('div');
          cameraPreview.style.flex = '1';
          cameraPreview.style.position = 'relative';
          cameraPreview.style.overflow = 'hidden';
          
          const cameraVideo = document.createElement('video');
          cameraVideo.setAttribute('autoplay', '');
          cameraVideo.setAttribute('playsinline', '');
          cameraVideo.style.width = '100%';
          cameraVideo.style.height = '100%';
          cameraVideo.style.objectFit = 'cover';
          
          const cameraControls = document.createElement('div');
          cameraControls.style.padding = '20px';
          cameraControls.style.display = 'flex';
          cameraControls.style.justifyContent = 'space-around';
          cameraControls.style.backgroundColor = 'rgba(0,0,0,0.7)';
          
          const cancelButton = document.createElement('button');
          cancelButton.textContent = 'å–æ¶ˆ';
          cancelButton.classList.add('btn-danger');
          
          const captureButton = document.createElement('button');
          captureButton.textContent = 'æ‹æ”';
          captureButton.classList.add('btn-secondary');
          
          cameraControls.appendChild(cancelButton);
          cameraControls.appendChild(captureButton);
          
          cameraPreview.appendChild(cameraVideo);
          cameraContainer.appendChild(cameraPreview);
          cameraContainer.appendChild(cameraControls);
          
          document.body.appendChild(cameraContainer);
          
          // è«‹æ±‚ç›¸æ©Ÿæ¬Šé™
          navigator.mediaDevices.getUserMedia({ 
            video: { 
              facingMode: 'environment', // ä½¿ç”¨å¾Œç½®ç›¸æ©Ÿ
              width: { ideal: 1920 },
              height: { ideal: 1080 }
            } 
          })
          .then(function(stream) {
            videoElement.srcObject = stream;
            cameraVideo.srcObject = stream;
            
            // æ‹ç…§æŒ‰éˆ•äº‹ä»¶
            captureButton.addEventListener('click', () => {
              const tempCanvas = document.createElement('canvas');
              tempCanvas.width = cameraVideo.videoWidth;
              tempCanvas.height = cameraVideo.videoHeight;
              const tempCtx = tempCanvas.getContext('2d');
              
              // ç¹ªè£½è¦–é »å¹€åˆ°canvas
              tempCtx.drawImage(cameraVideo, 0, 0);
              
              // å°‡canvasè½‰æ›ç‚ºBlob
              tempCanvas.toBlob((blob) => {
                // å‰µå»ºä¸€å€‹Fileå°è±¡
                const file = new File([blob], "camera-capture.jpg", { type: "image/jpeg" });
                
                // åŠ è¼‰åœ–ç‰‡
                loadImageFromFile(file);
                
                // æ¸…ç†
                stream.getTracks().forEach(track => track.stop());
                document.body.removeChild(cameraContainer);
                document.body.removeChild(videoElement);
              }, 'image/jpeg', 0.95);
            });
            
            // å–æ¶ˆæŒ‰éˆ•äº‹ä»¶
            cancelButton.addEventListener('click', () => {
              stream.getTracks().forEach(track => track.stop());
              document.body.removeChild(cameraContainer);
              document.body.removeChild(videoElement);
            });
          })
          .catch(function(error) {
            showNotification('ç„¡æ³•å­˜å–ç›¸æ©Ÿ: ' + error.message, 'error');
            document.body.removeChild(cameraContainer);
            document.body.removeChild(videoElement);
          });
        });
      } else {
        takePictureBtn.style.display = 'none';
      }
    }
    
    // äº‹ä»¶ç›£è½å™¨
    function setupEventListeners() {
      // æª”æ¡ˆé¸æ“‡æŒ‰éˆ•
      selectPhotoBtn.addEventListener('click', () => {
        imgInput.click();
      });
      
      imgInput.addEventListener("change", e => loadImageFromFile(e.target.files[0]));
      
      // æ»‘æ¡¿äº‹ä»¶
      xStartSlider.addEventListener("input", syncSliderValues);
      xEndSlider.addEventListener("input", syncSliderValues);
      xCalibrateSlider.addEventListener("input", () => {
        syncSliderValues();
        if (rawData) extractAndPlot();
      });
      
      // åˆ†æå’Œæ ¡æ­£æŒ‰éˆ•
      analyzeBtn.addEventListener("click", extractAndPlot);
      addPointBtn.addEventListener("click", addCalibrationPoint);
      generateRegressionBtn.addEventListener("click", generateRegression);
      plotWavelengthBtn.addEventListener("click", plotWavelengthGraph);
      toggleBackgroundBtn.addEventListener("click", toggleBackground);
      
      // æ³¢é•·è¼¸å…¥æ¡†æŒ‰Enterç¢ºèª
      wavelengthInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          addCalibrationPoint();
        }
      });
      
      // ç›£è½çª—å£å¤§å°è®ŠåŒ–
      window.addEventListener('resize', () => {
        if (img.complete && img.naturalWidth > 0) {
          setupCanvas();
          requestAnimationFrame(drawWithRectangle);
        }
      });
      
      // ç¦ç”¨é›™æŒ‡ç¸®æ”¾é é¢
      document.addEventListener('gesturestart', (e) => {
        e.preventDefault();
      }, { passive: false });
      
      document.addEventListener('gesturechange', (e) => {
        e.preventDefault();
      }, { passive: false });
    }
    
    // ä¿å­˜æ•¸æ“šåˆ°æœ¬åœ°å­˜å„²
    function saveDataToLocalStorage() {
      if (calibrationPoints.length > 0) {
        localStorage.setItem('spectrumTool_calibrationPoints', JSON.stringify(calibrationPoints));
      }
      
      if (calibration) {
        localStorage.setItem('spectrumTool_calibration', JSON.stringify(calibration));
      }
    }
    
    // å¾æœ¬åœ°å­˜å„²åŠ è¼‰æ•¸æ“š
    function loadDataFromLocalStorage() {
      const savedCalibrationPoints = localStorage.getItem('spectrumTool_calibrationPoints');
      if (savedCalibrationPoints) {
        try {
          calibrationPoints = JSON.parse(savedCalibrationPoints);
          updateCalibrationTable();
        } catch (e) {
          console.error("ç„¡æ³•è¼‰å…¥æ ¡æº–é»:", e);
        }
      }
      
      const savedCalibration = localStorage.getItem('spectrumTool_calibration');
      if (savedCalibration) {
        try {
          calibration = JSON.parse(savedCalibration);
          if (calibration && calibration.a && calibration.b) {
            regressionConfirmed = true;
            regressionResult.textContent = `Î» = ${calibration.a.toFixed(4)} Ã— x + ${calibration.b.toFixed(2)}`;
          }
        } catch (e) {
          console.error("ç„¡æ³•è¼‰å…¥æ ¡æº–:", e);
        }
      }
    }
    
    // åˆå§‹åŒ–æ‡‰ç”¨
    function initApp() {
      setupCanvas();
      setupEventListeners();
      setupGestureEvents();
      setupCameraIntegration();
      loadDataFromLocalStorage();
      
      // å®šæœŸä¿å­˜æ•¸æ“š
      setInterval(saveDataToLocalStorage, 30000); // æ¯30ç§’è‡ªå‹•ä¿å­˜
      
      // æª¢æ¸¬æ˜¯å¦ç‚ºiPad
      const isIpad = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      
      if (isIpad) {
        // é¡¯ç¤ºæ·»åŠ åˆ°ä¸»å±å¹•æç¤º
        const isStandalone = window.navigator.standalone;
        const hasShownPrompt = localStorage.getItem('hasShownHomeScreenPrompt');
        
        if (!isStandalone && !hasShownPrompt) {
          setTimeout(() => {
            showAddToHomeScreenPrompt();
            localStorage.setItem('hasShownHomeScreenPrompt', 'true');
          }, 3000);
        }
      }
    }
    
    // é¡¯ç¤ºæ·»åŠ åˆ°ä¸»å±å¹•æç¤º
    function showAddToHomeScreenPrompt() {
      const promptContainer = document.createElement('div');
      promptContainer.style.position = 'fixed';
      promptContainer.style.bottom = '0';
      promptContainer.style.left = '0';
      promptContainer.style.right = '0';
      promptContainer.style.backgroundColor = '#3b82f6';
      promptContainer.style.color = 'white';
      promptContainer.style.padding = '15px';
      promptContainer.style.boxShadow = '0 -2px 10px rgba(0,0,0,0.2)';
      promptContainer.style.zIndex = '9999';
      promptContainer.style.display = 'flex';
      promptContainer.style.alignItems = 'center';
      promptContainer.style.justifyContent = 'space-between';
      
      const promptText = document.createElement('div');
      promptText.innerHTML = '<strong>æ·»åŠ åˆ°ä¸»å±å¹•</strong><br>ç²å¾—æ›´å¥½çš„ä½¿ç”¨é«”é©—';
      
      const promptActions = document.createElement('div');
      promptActions.style.display = 'flex';
      promptActions.style.gap = '10px';
      
      const dismissBtn = document.createElement('button');
      dismissBtn.textContent = 'ç¨å¾Œå†èªª';
      dismissBtn.classList.add('btn-outline');
      dismissBtn.style.backgroundColor = 'transparent';
      dismissBtn.style.color = 'white';
      dismissBtn.style.border = '1px solid white';
      
      const addBtn = document.createElement('button');
      addBtn.textContent = 'å¦‚ä½•æ·»åŠ ';
      addBtn.classList.add('btn-secondary');
      
      promptActions.appendChild(dismissBtn);
      promptActions.appendChild(addBtn);
      
      promptContainer.appendChild(promptText);
      promptContainer.appendChild(promptActions);
      
      document.body.appendChild(promptContainer);
      
      dismissBtn.addEventListener('click', () => {
        document.body.removeChild(promptContainer);
      });
      
      addBtn.addEventListener('click', () => {
        const instructionsContainer = document.createElement('div');
        instructionsContainer.style.position = 'fixed';
        instructionsContainer.style.top = '0';
        instructionsContainer.style.left = '0';
        instructionsContainer.style.right = '0';
        instructionsContainer.style.bottom = '0';
        instructionsContainer.style.backgroundColor = 'rgba(0,0,0,0.8)';
        instructionsContainer.style.zIndex = '10000';
        instructionsContainer.style.display = 'flex';
        instructionsContainer.style.flexDirection = 'column';
        instructionsContainer.style.alignItems = 'center';
        instructionsContainer.style.justifyContent = 'center';
        instructionsContainer.style.padding = '20px';
        
        const instructions = document.createElement('div');
        instructions.style.backgroundColor = 'white';
        instructions.style.borderRadius = '12px';
        instructions.style.padding = '20px';
        instructions.style.maxWidth = '400px';
        instructions.style.width = '100%';
        instructions.style.textAlign = 'center';
        
        instructions.innerHTML = `
          <h3 style="margin-top:0;">æ·»åŠ åˆ°ä¸»å±å¹•æ­¥é©Ÿ</h3>
          <p>1. é»æ“ŠSafariåº•éƒ¨çš„<strong>åˆ†äº«æŒ‰éˆ•</strong> <span style="font-size:24px;">â¬†ï¸</span></p>
          <p>2. åœ¨é¸é …ä¸­æ‰¾åˆ°ä¸¦é»æ“Š<strong>æ·»åŠ åˆ°ä¸»å±å¹•</strong></p>
          <p>3. é»æ“Š<strong>æ·»åŠ </strong>ç¢ºèª</p>
          <button id="closeInstructions" style="margin-top:15px;padding:10px 20px;background-color:#3b82f6;color:white;border:none;border-radius:8px;font-weight:500;">äº†è§£äº†</button>
        `;
        
        instructionsContainer.appendChild(instructions);
        document.body.appendChild(instructionsContainer);
        
        document.getElementById('closeInstructions').addEventListener('click', () => {
          document.body.removeChild(instructionsContainer);
          document.body.removeChild(promptContainer);
        });
      });
    }
    
    // æª¢æŸ¥å’Œè™•ç†é›¢ç·šæ¨¡å¼
    function setupOfflineSupport() {
      window.addEventListener('online', () => {
        showNotification('å·²æ¢å¾©ç¶²çµ¡é€£æ¥', 'success');
      });
      
      window.addEventListener('offline', () => {
        showNotification('å·²é€²å…¥é›¢ç·šæ¨¡å¼', 'info');
      });
      
      // å¦‚æœå·²ç¶“é›¢ç·šï¼Œé¡¯ç¤ºæç¤º
      if (!navigator.onLine) {
        showNotification('ç•¶å‰è™•æ–¼é›¢ç·šæ¨¡å¼', 'info');
      }
    }
    
    // åˆå§‹åŒ–æ‡‰ç”¨
    setupOfflineSupport();
    initApp();
  </script>
</body>
</html>